<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.4/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.4/ http://www.mediawiki.org/xml/export-0.4.xsd" version="0.4" xml:lang="en">
  <siteinfo>
    <sitename>DAE Tools</sitename>
    <base>http://daetools.sourceforge.net/w/index.php/Main_Page</base>
    <generator>MediaWiki 1.16.2</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">DAE Tools</namespace>
      <namespace key="5" case="first-letter">DAE Tools talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="262" case="first-letter">Math</namespace>
      <namespace key="263" case="first-letter">Math talk</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>About</title>
    <id>6</id>
    <revision>
      <id>14</id>
      <timestamp>2011-04-03T08:37:57Z</timestamp>
      <contributor>
        <username>Ciroki</username>
        <id>1</id>
      </contributor>
      <comment>Created page with &quot;== Author == [[Image:Photo.jpg|frame|Dragan Nikolic]]   '''Dragan Nikolic'''  Send your comments and questions at: '''dnikolic - daetools.com '''  OpenPGP public key: [dnikolic-0...&quot;</comment>
      <text xml:space="preserve">== Author ==
[[Image:Photo.jpg|frame|Dragan Nikolic]]


'''Dragan Nikolic'''

Send your comments and questions at: '''dnikolic - daetools.com '''

OpenPGP public key: [dnikolic-0x8670ECEC-pub.asc 0x8670ECEC]

== Short Biography ==

=== Education ===

* '''Diploma in chemical engineering''', University of Belgrade, Serbia
* '''PhD''', University of Western Macedonia, Greece

=== Work experience ===

* '''ICN Galenika''' Belgrade, Serbia ('''2000-2005''') Research Assistant, Institute for R&amp;amp;D, Chemical pilot plant
* '''Aristotle University Thessaloniki''', Thessaloniki, Greece ('''2005-2008''') Early Stage Researcher, Marie Curie RTN &quot;''Towards Knowledge-Based Processing Systems ''(''PRISM'')&quot;
* '''Trinity College Dublin''', Dublin, Ireland ('''2008-2009''') Research Associate, Department of Mechanical &amp;amp; Manufacturing Engineering

=== Research interests ===

* Computer-Aided techniques for modelling, simulation and optimization of chemical processing plants
* Computer programming (c/c , python)
* Modelling and optimization of advanced gas separations (hybrid PSA/Membrane)
* Heat transfer and heat exchanger design
* Scale-up of laboratory procedures to full-scale Active Pharmaceutical Ingredients (API) production
* Software development for optimizations of tube count and tube layout of shell-and-tube heat exchangers

=== Journal publications ===

* Nikolic, D.; Giovanoglou, A.; Georgiadis, M.C.; Kikkinides, E.S. ''Generic modeling framework for gas separations using multibed pressure swing adsorption processes''. '''Ind. Eng. Chem. Res.''', 47(9), 3156 ('''2008''').
* Nikolic, D.; Kikkinides, E.S.; Georgiadis, M.C. ''Optimization of Multibed Pressure Swing Adsorption Processes'', ''Ind. Eng. Chem. Res''., 48, 5388 (''2009'').
* Krokos C.A.; Nikolic D.; Kikkinides E.S.; Georgiadis M.C.; Stubos A.K. ''Modeling and optimization of multi-tubular metal hydride beds for efficient hydrogen storage''. '''International Journal of Hydrogen Energy''', 34 (22), 9128 ('''2009''').

=== Conferences ===

* Nikolic, D.; Georgiadis, M.C.; Kikkinides, E.S. M''odelling and optimization of multibed pressure swing adsorption flowsheets'', '''PRES''' '''2006''', Prague.
* Nikolic, D.; Georgiadis, M.C.; Kikkinides, E.S. ''Modelling and optimization of multibed Pressure swing adsorption flowsheets'', '''ESCAPE 17''', '''2007''', Bucharest, Romania.
* Nikolic, D.; Giovanoglou, A.; Georgiadis, M.C.; Kikkinides, E.S. S''imultaneous production of hydrogen and carbon dioxide from steam methane off gas using multibed pressure swing adsorption systems'', '''PRES''' '''2007''', Ischia, Italy.
* Nikolic, D.; Georgiadis, M.C.; Kikkinides, E.S. ''Modeling and optimization of single and multi-layer pressure swing adsorption systems'', '''ECCE 6''', '''2007''', Copenhagen, Denmark.
* Nikolic, D.; Georgiadis, M.C.; Kikkinides, E.S. A''n optimization framework of multibed pressure swing adsorption systems'', '''ESCAPE 18''', '''2008''', Lyon, France.
* Nikolic, D.; Hutchison, M.; Sapin, P.T.; Robinson, A.J. ''Hot spot targeting with a liquid impinging jet array waterblock'', '''Therminic 2009''', Leuven, Belgium.

=== Book chapters ===

* ''Modeling of Pressure Swing Adsorption Processes'' in J. Banga, M. Georgiadis, E. Pistikopoulos;. Volume 7: '''Dynamic Process Modelling''', '''Process Systems Engineering''' (7 Volume Set), Wiley-VCH, edited by E. Pistikopoulos, M. Georgiadis and V. Dua ('''2010''')</text>
    </revision>
  </page>
  <page>
    <title>Documentation</title>
    <id>5</id>
    <revision>
      <id>135</id>
      <timestamp>2011-04-04T15:33:40Z</timestamp>
      <contributor>
        <username>Ciroki</username>
        <id>1</id>
      </contributor>
      <text xml:space="preserve">[[Getting_DAE_Tools|Getting DAE Tools]]

[[Getting_started|Getting Started]]

[[Tutorials|Tutorials]]

[[PyDAE_user_guide|pyDAE User Guide]]

pyDAE API Reference

* [http://{{SERVERNAME}}/api_ref/core.html Core module]
* [http://{{SERVERNAME}}/api_ref/activity.html Activity module]
* [http://{{SERVERNAME}}/api_ref/solver.html Solver module]
* [http://{{SERVERNAME}}/api_ref/datareporting.html DataReporter module]
* [http://{{SERVERNAME}}/api_ref/logging.html Logging module]</text>
    </revision>
  </page>
  <page>
    <title>Downloads</title>
    <id>4</id>
    <revision>
      <id>138</id>
      <timestamp>2011-04-04T15:41:56Z</timestamp>
      <contributor>
        <username>Ciroki</username>
        <id>1</id>
      </contributor>
      <text xml:space="preserve">Make sure you have installed: Python 2.6, Boost libraries (GNU/Linux only), Numpy, Matplotlib and PyQt4. For more information see [[Getting_DAE_Tools|Getting DAE Tools]].

=== Current version (1.1.0) ===

{|
! class=&quot;first&quot; style=&quot;text-align: center&quot; | OS
! style=&quot;text-align: center&quot; | Architecture
! class=&quot;th150&quot; style=&quot;text-align: center&quot; | File
! class=&quot;th150&quot; style=&quot;text-align: center&quot; | Notes
|- class=&quot;dl&quot;
| class=&quot;first&quot; style=&quot;text-align: left&quot; | Debian Squeeze
| style=&quot;text-align: center&quot; | x86_64
|
[http://sourceforge.net/projects/daetools/files/1.1.0/daetools_1.1.0_amd64_debian-6.deb daetools_1.1.0_amd64_debian-6.deb]
|
|- class=&quot;dl&quot;
| class=&quot;first&quot; style=&quot;text-align: left&quot; | Ubuntu 10.10
| style=&quot;text-align: center&quot; | x86_64
|
[http://sourceforge.net/projects/daetools/files/1.1.0/daetools_1.1.0_amd64_ubuntu-10.10.deb daetools_1.1.0_amd64_ubuntu-10.10.deb]
|
|- class=&quot;dl&quot;
| class=&quot;first&quot; style=&quot;text-align: left&quot; | Fedora 14
| style=&quot;text-align: center&quot; | x86_64
|
[http://sourceforge.net/projects/daetools/files/1.1.0/daetools_1.1.0_amd64_fedora-14.rpm daetools_1.1.0_amd64_fedora-14.rpm]
|
|- class=&quot;dl&quot;
| class=&quot;first&quot; style=&quot;text-align: left&quot; | Windows XP
| style=&quot;text-align: center&quot; | x86
|
[http://sourceforge.net/projects/daetools/files/1.1.0/daetools_1.1.0_win32_winxp_python26.exe daetools_1.1.0_win32_winxp_python26.exe]
|
|- class=&quot;dl&quot;
| class=&quot;first&quot; style=&quot;text-align: left&quot; | Debian Squeeze
| style=&quot;text-align: center&quot; | x86
|
[http://sourceforge.net/projects/daetools/files/1.1.0/daetools_1.1.0_i386_debian-6.deb daetools_1.1.0_i386_Debian-6.deb]
|
|- class=&quot;dl&quot;
| class=&quot;first&quot; style=&quot;text-align: left&quot; | Ubuntu 10.10
| style=&quot;text-align: center&quot; | x86
|
[http://sourceforge.net/projects/daetools/files/1.1.0/daetools_1.1.0_i386_ubuntu-10.10.deb daetools_1.1.0_i386_ubuntu-10.10.deb]
|
|- class=&quot;dl&quot;
| class=&quot;first&quot; style=&quot;text-align: left&quot; | Fedora 14
| style=&quot;text-align: center&quot; | x86
|
[http://sourceforge.net/projects/daetools/files/1.1.0/daetools_1.1.0_i386_fedora-14.rpm daetools_1.1.0_i386_fedora-14.rpm]
|
|}

For any other operating system and architecture contact [About] the author. 

=== Older versions: ===

{|
! class=&quot;first&quot; style=&quot;text-align: center&quot; | OS
! style=&quot;text-align: center&quot; | Architecture
! class=&quot;th150&quot; style=&quot;text-align: center&quot; | File
! class=&quot;th150&quot; style=&quot;text-align: center&quot; | Notes
|- class=&quot;dl&quot;
| class=&quot;first&quot; style=&quot;text-align: left&quot; | Debian Squeeze
| style=&quot;text-align: center&quot; | x86_64
|
[http://sourceforge.net/projects/daetools/files/1.0-5/daetools_1.0-5_amd64_debian-6.deb daetools_1.0-5_amd64_debian-6.deb]
|
|- class=&quot;dl&quot;
| class=&quot;first&quot; style=&quot;text-align: left&quot; | Ubuntu 10.10&lt;br /&gt;
| style=&quot;text-align: center&quot; | x86_64
|
[http://sourceforge.net/projects/daetools/files/1.0-5/daetools_1.0-5_amd64_ubuntu-10.10.deb daetools_1.0-5_amd64_ubuntu-10.10.deb]
| &lt;br /&gt;
|- class=&quot;dl&quot;
| class=&quot;first&quot; style=&quot;text-align: left&quot; | Fedora 14&lt;br /&gt;
| style=&quot;text-align: center&quot; | x86_64
|
[http://sourceforge.net/projects/daetools/files/1.0-5/daetools_1.0-5_amd64_fedora-14.rpm daetools_1.0-5_amd64_fedora-14.rpm]
| &lt;br /&gt;
|- class=&quot;dl&quot;
| class=&quot;first&quot; style=&quot;text-align: left&quot; | Windows XP&lt;br /&gt;
| style=&quot;text-align: center&quot; | x86&lt;br /&gt;
|
[http://sourceforge.net/projects/daetools/files/1.0-5/daetools_1.0-5_win32_winxp_python26.exe daetools_1.0-5_win32_winxp_python26.exe]
| &lt;br /&gt;
|- class=&quot;dl&quot;
| class=&quot;first&quot; style=&quot;text-align: left&quot; | Debian Squeeze&lt;br /&gt;
| style=&quot;text-align: center&quot; | x86
|
[http://sourceforge.net/projects/daetools/files/1.0-5/daetools_1.0-5_i386_debian-6.deb daetools_1.0-5_i386_Debian-6.deb]&lt;br /&gt;
| &lt;br /&gt;
|- class=&quot;dl&quot;
| class=&quot;first&quot; style=&quot;text-align: left&quot; | Ubuntu 10.10&lt;br /&gt;
| style=&quot;text-align: center&quot; | x86
|
[http://sourceforge.net/projects/daetools/files/1.0-5/daetools_1.0-5_i386_ubuntu-10.10.deb daetools_1.0-5_i386_ubuntu-10.10.deb]
| &lt;br /&gt;
|- class=&quot;dl&quot;
| class=&quot;first&quot; style=&quot;text-align: left&quot; | Fedora 14&lt;br /&gt;
| style=&quot;text-align: center&quot; | x86
|
[http://sourceforge.net/projects/daetools/files/1.0-5/daetools_1.0-5_i386_fedora-14.rpm daetools_1.0-5_i386_fedora-14.rpm]
| &lt;br /&gt;
|}</text>
    </revision>
  </page>
  <page>
    <title>Getting DAE Tools</title>
    <id>19</id>
    <revision>
      <id>130</id>
      <timestamp>2011-04-04T15:29:56Z</timestamp>
      <contributor>
        <username>Ciroki</username>
        <id>1</id>
      </contributor>
      <minor/>
      <comment>moved [[Getting dae tools]] to [[Getting DAE Tools]]</comment>
      <text xml:space="preserve">== Introduction ==

'''DAE Tools''' (pyDAE module) is installed in daetools folder within site-packages (or dist-packages) folder under python (tipically /usr/lib/python26/Lib or C:\Python2.6\Lib). The structure of the folders is the following:

* daetools
** daePlotter
** daeSimulator
** docs
** examples
** solvers

== Requirements ==

Mandatory packages:

* Python (v2.6&lt;sup&gt;+&lt;/sup&gt;): [http://www.python.org]
* Boost libraries (v1.35 ; GNU/Linux only): [http://www.boost.org]
* Numpy (v1.3&lt;sup&gt;+&lt;/sup&gt;): [http://numpy.scipy.org]
* Matplotlib (v0.99&lt;sup&gt;+&lt;/sup&gt;): [http://matplotlib.sourceforge.net]
* pyQt4 (v4.3&lt;sup&gt;+&lt;/sup&gt;): [http://www.riverbankcomputing.co.uk/software/pyqt]
* Lapack (GNU/Linux only): [http://www.netlib.org/lapack]
* Atlas (GNU/Linux only): [http://math-atlas.sourceforge.net]

Optional packages (3rd party linear solvers):

* Umfpack (v5.4&lt;sup&gt;+&lt;/sup&gt;; GNU/Linux only)
* Intel MKL (v10.2.5.035) - proprietary
* AMD ACML (v4.4.0) - proprietary

For more information on how to install packages please refer to the documentation for the specific library. By default GNU/Linux and Windows versions come with the default Sundials dense LU linear solver, Trilinos Amesos with built-in support for Lapack and SuperLU linear solvers and BONMIN with support for MUMPS linear solver (with PORD ordering). Additional linear solvers: Umfpack for Trilinos Amesos (GNU/Linux only), AMD ACML and Intel MKL must be downloaded separately since they are not free software.

== Getting the packages ==

First [[Downloads|download]] the appropriate installer for your operating system (GNU/Linux, Windows) and architecture (i386, amd64, arm):

* .deb for Debian GNU/Linux and derivatives
* .rpm for Red Hat GNU/Linux and derivatives
* .exe for Windows

== Installation ==

=== Debian GNU/Linux (and derivatives) ===

First install the mandatory packages. To do so you can use the Synaptic Package Manager or type the following commands:

&lt;syntaxhighlight lang=&quot;bash&quot;&gt;
sudo apt-get install libboost-all-dev python-qt4 python-numpy python-matplotlib 
sudo apt-get install liblapack3gf libblas3gf
&lt;/syntaxhighlight&gt;

Optionally you may install some Umfpack linear solver and 3D plotting library:
&lt;syntaxhighlight lang=&quot;bash&quot;&gt;
sudo apt-get install libamd2.2.0 libumfpack5.4.0
sudo apt-get install mayavi2
&lt;/syntaxhighlight&gt;

Install '''DAE Tools''' by using GDebi package installer or by typing the following shell commands:
&lt;syntaxhighlight lang=&quot;bash&quot;&gt;
cd Directory_where_you_downloaded_the_package
sudo dpkg -i daetools_x.x.x_amd64_debian-6.deb
&lt;/syntaxhighlight&gt;

=== Red Hat GNU/Linux (and derivatives) ===

First install the mandatory packages. To do so can use the Package Manager or type the following commands:
&lt;syntaxhighlight lang=&quot;bash&quot;&gt;
sudo yum install boost-devel PyQt4 numpy python-matplotlib
sudo yum install blas lapack
&lt;/syntaxhighlight&gt;

Optionally you may install Umfpack linear solver and 3D plotting library:

&lt;syntaxhighlight lang=&quot;bash&quot;&gt;
sudo yum install suitesparse
sudo yum install Mayavi
&lt;/syntaxhighlight&gt;

Install '''DAE Tools''' by using Package Installer or by typing the following shell commands:

&lt;syntaxhighlight lang=&quot;bash&quot;&gt;
cd Directory_where_you_downloaded_the_package
sudo rpm -i daetools_x.x.x_amd64_fedora-14.rpm
&lt;/syntaxhighlight&gt;

=== Windows ===

So far it is tested on Windows XP only. First install the necessary dependencies (except the boost library, which is pre-built and comes with'''DAE Tools''') in the following order: '''python''', '''numpy''', '''matplotlib''', '''pyqt4'''. As a starting point you can use the following links:

* Python 2.6: [http://www.python.org/ftp/python/2.6.6/python-2.6.6.msi download link]
* Numpy: [https://sourceforge.net/projects/numpy/files/NumPy/1.5.1/ downloads link]
* Matplotlib: [http://sourceforge.net/projects/matplotlib/files/matplotlib/matplotlib-1.0.1 downloads link]
* PyQt4: [http://www.riverbankcomputing.co.uk/static/Downloads downloads link]

To be able to create 3D plots you need to install Mayavi2 package.  Alternatively you can install everything needed through [http://www.pythonxy.com Python(x,y)]. Then install '''DAE Tools''' by double clicking the file daetools_x.x-x_win32_winxp_python26.exe and follow the instructions.

=== Additional linear equation solvers (proprietary) ===

Optionally you can also install proprietary [http://www.amd.com/acml AMD ACML] and [http://software.intel.com/en-us/intel-mkl/ Intel MKL] libraries. Please follow the installation procedures in the documentation. '''pyAmdACML''' and '''pyIntelMKL/pyIntelPardiso''' modules are compiled against ACML 4.4.0 and MKL 10.2.5.035 respectively. Also have a look on the licensing conditions ('''these libraries are not''' [http://www.gnu.org/philosophy/free-sw.html '''free software''']).

In order to use AMD ACML and Intel MKL libraries you have to do some additional configuration. You can follow the instructions in the corresponding package documentation or do a quick setup as described below:

#'''GNU/Linux''': setup for a single user&lt;br /&gt; Copy [acml_mkl_bashrc this file] to your home folder, edit it so that it reflects your installation and add the line. $HOME/acml_mkl_bashrc  at the end of $HOME/.bashrc file
#'''GNU/Linux''': setup for all users&lt;br /&gt; Subject to your machine architecture and library versions (here '''x86_64''' GNU/Linux with '''ACML v4.4.0''' and '''MKL v10.2.5.035'''), put the following lines in /etc/ld.so.conf and execute ldconfig: /opt/intel/mkl/10.2.5.035/lib/em64t /opt/acml4.4.0/gfortran64_mp/lib
#'''Windows XP''':&lt;br /&gt; If not already added, add the following line to your '''PATH''' environment variable (Control Panel -&gt; System): c:\AMD\acml4.4.0\ifort32_mp\lib;c:\Intel\MKL\10.2.5.035\ia32\bin\

== Compiling DAE Tools from source ==

=== Compiling of DAE Tools core libraries and python modules ===

To compile the source you need the following:

* Installed boost library (v1.35 or higher) headers and compiled'''system, thread''' and'''python''' libraries
* Installed python 2.6/2.7
* Installed python numpy module
* Optionally: Bonmin, Trilinos Amesos, SuperLU, Blas/Lapack, Amd ACML and Intel MKL libraries.

All DAE Tools modules are developed using the QtCreator cross-platform integrated development environment. If you install the above dependecies correctly there is no much tweaking needed. Check out the source code from the [https://daetools.svn.sourceforge.net/svnroot/daetools DAE Tools subversion repository]:

&lt;syntaxhighlight lang=&quot;bash&quot;&gt;
svn co https://daetools.svn.sourceforge.net/svnroot/daetools daetools
&lt;/syntaxhighlight&gt;

=== GNU/Linux&lt;br /&gt; ===

* Install the necessary dependencies ('''boost-devel, numpy''')
* Install '''QtCreator'''

'''Debian GNU/Linux''' based:

&lt;syntaxhighlight lang=&quot;bash&quot;&gt;
sudo apt-get install qtcreator
&lt;/syntaxhighlight&gt;

'''Red Hat GNU/Linux''' based:

&lt;syntaxhighlight lang=&quot;bash&quot;&gt;
sudo yum install qtcreator
&lt;/syntaxhighlight&gt;

* Check '''dae-tools/trunk/dae.pri''' file&lt;br /&gt; Here you should check the following variables:&lt;br /&gt; 
**'''PYTHONDIR'''&lt;br /&gt; Tipically /usr/lib/python2.6 or /usr/lib64/python2.6 depending whether you are running 32 or 64 bit GNU/Linux. 
**Check the python version - it can be 2.7 in Fedora 14, for instance.
**'''PYTHON_SITE_PACKAGES_DIR'''&lt;br /&gt; Typically it is '''$${PYTHONDIR}\site-packages''', but can be '''$${PYTHONDIR}\dist-packages''' in Debian GNU/Linux based distributions.&lt;br /&gt; 
**'''PYTHON_INCLUDE_DIR'''&lt;br /&gt; You might need to add /usr/include/python2.6/numpy for Debian Squeeze if the header '''_numpyconfig.h''' is missing: '''Bug#589592'''.

* Build the following third party libraries:
**Boost 1.35 (Windows only)
**Blas/Lapack or CLapack on Windows
**Bonmin MUMPS
**Sundials IDAS 1.0.0
**SuperLU 4.1
**Trilinos Amesos 10.4&lt;br /&gt; '''TODO:''' The details how to build the above libraries on GNU/Linux and Windows.
* Choose the right specification file for your platform (usually it is done automatically by the IDE, but double-check it):
**for 32 bit machines use '''-spec linux-g++'''  
**for 64 bit machines use '''-spec linux-g++-64'''

* Build the project '''dae''' through the QtCreator IDE or by the following commands:

&lt;syntaxhighlight lang=&quot;bash&quot;&gt;
cd daetools/trunk
qmake-qt4 dae.pro -r -spec linux-g++-64 CONFIG=release
make
&lt;/syntaxhighlight&gt;

* As a result there should be the following static/dynamic libraries in the '''debug'''/'''release''' folders:
**libcdaeCore.a, libcdaeActivity.a, libcdaeDataReporting.a, libcdaeIDAS_DAESolver.a, libcdaeBONMIN_MINLPSolver.a
**pyCore.so, pyActivity.so, pyDataReporting.so, pyIDAS.so, pyBONMIN.so

=== Windows ===

* Install the necessary dependencies ('''python 2.6, numpy''')
* Install MS Visual Studio 2008 or newer (Express Edition also works)
* Download and unpack the '''boost''' library source to '''dae-tools/trunk/boost''' folder and build the libraries (look on http://www.boost.org/doc/tools/build/doc/html/index.html for the help)
* Download and install Qt Open Source libraries for windows http://qt.nokia.com/products (for MS VC )
* Check '''dae-tools/trunk/dae.pri''' file&lt;br /&gt; Here you should check the following variables:
**'''PYTHONDIR'''&lt;br /&gt;  Tipically c:\Python26.
**''BOOSTDIR''','''BOOSTLIBPATH'''&lt;br /&gt;  If you installed'''boost''' library to dae-tools/trunk/boost everything is fine; otherwise you have to point to the folder with the'''boost''' installation.
* Build the project '''dae''' through the QtCreator IDE or by the following commands:

&lt;syntaxhighlight lang=&quot;bash&quot;&gt;
cd daetools\trunk
qmake.exe dae.pro -spec win32-msvc2008 -r CONFIG =release
make
&lt;/syntaxhighlight&gt;

* As a result there should be the following static/dynamic libraries in the '''debug'''/'''release''' folders:
**Core.lib, Simulation.lib, DataReporters.lib, Solver.lib
**pyCore.pyd, pyActivity.pyd, pyDataReporting.pyd, pySolver.pyd
'''Note:''' You can also create Visual Studio projects. First edit dae.pri file as described above, open the '''Qt Command Prompt''' and use the following commands:

&lt;syntaxhighlight lang=&quot;bash&quot;&gt;
cd daetools\trunk
qmake -tp vc -r dae.pro
&lt;/syntaxhighlight&gt;

Now you can open created project in the MS Visual C IDE.</text>
    </revision>
  </page>
  <page>
    <title>Getting started</title>
    <id>21</id>
    <revision>
      <id>146</id>
      <timestamp>2011-04-04T16:33:18Z</timestamp>
      <contributor>
        <username>Ciroki</username>
        <id>1</id>
      </contributor>
      <comment>/* Parameters */</comment>
      <text xml:space="preserve">This chapter gives the basic information about what is needed to develop a model of a process, how to simulate/optimize it and how to obtain and plot the results of a process simulation/optimization. In general, the simulation/optimization of a process consists of three tasks:

# Modelling of a proces
# Defining a simulation/optimization
# Processing the results

== Programming language ==

'''DAE Tools''' core libraries are written in standard c++. However, [http://www.python.org/ Python] programming language is used as the main modelling language. The main reason for use of Python is (as the authors say): ''&quot;Python is an easy to learn, powerful programming language. It has efficient high-level data structures and a simple but effective approach to object-oriented programming. Python's elegant syntax and dynamic typing, together with its interpreted nature, make it an ideal language for scripting and rapid application development in many areas on most platforms&quot; [http://docs.python.org/tutorial]''. ''And: &quot;''Often, programmers fall in love with Python because of the increased productivity it provides. Since there is no compilation step, the edit-test-debug cycle is incredibly fast&quot;'' [http://www.python.org/doc/essays/blurb]''. Also, please have a look on [http://www.python.org/doc/essays/comparisons/ a comparison to the other languages]. Based on the information available online, and according to the personal experience, the python programs are much shorter and take an order of magnitude less time to develop it. Initially I developed daePlotter module in c++; it took me about one month of part time coding. But, then I moved to python: reimplementing it in PyQt took me just two days (with several new features added), while the code size shrank from 24 cpp modules to four python modules only! ''&quot;Where Python code is typically 3-5 times shorter than equivalent Java code, it is often 5-10 times shorter than equivalent C++ code! Anecdotal evidence suggests that one Python programmer can finish in two months what two C++ programmers can't complete in a year. Python shines as a glue language, used to combine components written in C++&quot;'' [http://www.python.org/doc/essays/comparisons]. Obviously, not everything can be developed in python; for complex projects I still prefer the heavy c++ artillery.

== The main concepts ==

To efficiently model a real world user should be familiar with the following concepts:

* '''Model'''&lt;br /&gt;A model of the process is a simplified abstraction of real world process/phenomena describing its most important/driving elements and their interactions. In '''DAE Tools''' models are created by defining their parameters, distribution domains, variables, equations, and ports.
** '''Distribution domain'''&lt;br /&gt;Domain is a general term used to define an array of different objects (parameters, variables, equations but models and ports as well).&lt;br /&gt;
** '''Parameter'''&lt;br /&gt;Parameter can be defined as a time invariant quantity that will not change during a simulation.&lt;br /&gt;
** '''Variable'''&lt;br /&gt;Variable can be defined as a time variant quantity, also called a ''state variable''.&lt;br /&gt;
** '''Equation'''&lt;br /&gt;Equation can be defined as an expression used to calculate a variable value, which can be created by performing basic mathematical operations (+, -, *, /) and functions (such as sin, cos, tan, sqrt, log, ln, exp, pow, abs etc) on parameter and variable values (and time and partial derivatives as well).'''
** '''State transition network'''&lt;br /&gt; State transition networks are used to model a special type of equations: ''discontinuous equation''s. Discontinuous equations are equations that take different forms subject to certain conditions. They are composed of a finite number of ''states.''
** '''State'''&lt;br /&gt;States can be defined as a set of actions (in our case a set of equations) &lt;span style=&quot;font-weight: normal&quot;&gt;under current operating conditions. In addition, every state contains &lt;span style=&quot;font-weight: normal&quot;&gt;a set of state transitions which describe conditions when the state changes occur.'''
** '''State Transition'''&lt;br /&gt;State transition can be defined as a transition from the current to some other state, subject to given conditions. &lt;br /&gt;
** '''Port'''&lt;br /&gt;Ports are objects used to connect two models. Like models, they may contain domains, parameters and variables. &lt;br /&gt;
* '''Simulation'''&lt;br /&gt;Simulation of a process can be considered as the model run for certain input conditions. &lt;span style=&quot;font-weight: normal&quot;&gt;To define a simulation, several tasks are necessary such as: specifying information about domains and parameters, fixing the degrees of freedom by assigning values to certain variables, setting the initial conditions and many other (setting the initial guesses, absolute tolerances, etc).'''
* '''Optimization'''&lt;br /&gt;Process optimization can be considered as a process adjustment so as to minimize or maximize a specified goal while satisfying imposed set of constraints. The most common goals are minimizing cost, maximizing throughput, and/or efficiency. In general there are three types of parameters that can be adjusted to affect optimal performance:&lt;br /&gt; - Equipment optimization&lt;br /&gt; - Operating procedures&lt;br /&gt; - Control optimization'''
* '''Solver'''&lt;br /&gt;Solver is a set of mathematical procedures/algorithms necessary to solve a given set of equations. There are several types of solvers: Linear Algebraic solvers ('''LA'''), used to solve linear systems of equations; Nonlinear Algebraic solvers ('''NLA'''), used to solve non-linear systems of equations; Differential Algebraic solvers ('''DAE'''), used to solve mixed systems of differential and algebraic equations; Nonlinear Programming solvers ('''NLP'''), used to solve nonlinear optimization problems; Mixed-integer Nonlinear Programming solvers ('''MINLP'''), used to solve mixed-integer nonlinear optimization problems. In '''DAE Tools''' it is possible to choose '''DAE''' (currently only [https://computation.llnl.gov/casc/sundials/main.html Sundials IDAS]), '''NLP/MINLP''' (currently only [https://projects.coin-or.org/Bonmin IPOPT/BONMIN]), and '''LA''' solvers (built-in Sundials LA solvers; [http://trilinos.sandia.gov/packages/amesos/ Trilinos Amesos]&lt;nowiki&gt;: &lt;/nowiki&gt;[http://crd.lbl.gov/%7Exiaoye/SuperLU/index.html SuperLU], [http://www.cise.ufl.edu/research/sparse/umfpack Umfpack], or [http://www.netlib.org/Lapack Lapack]&lt;nowiki&gt;; &lt;/nowiki&gt;[http://software.intel.com/en-us/intel-mkl/ Intel MKL]&lt;nowiki&gt;; &lt;/nowiki&gt;[http://www.amd.com/acml AMD ACML]).
* '''Data Reporter'''&lt;br /&gt;Data reporter is defined as an object used to report the results of a simulation/optimization. They can either keep the results internally (and export them into a file, for instance) or send them via TCP/IP protocol to the '''DAE Tools''' plotter.
* '''Data Receiver'''&lt;br /&gt;Data receiver can be defined as on object which duty is to receive the results from a data reporter. These data can be later plotted or processed in some other ways.
* '''Log'''&lt;br /&gt; Log is defined as an object used to send messages from the various parts of '''DAE Tools''' framework (messages from solvers or simulation).

== Running a simulation ==

Two steps are needed to run a simulation:

1. Start '''daePlotter''':
*'''In GNU/Linux:''' &lt;br /&gt;Go to: '''Applications/Programming/daePlotter''' or type the following shell command: '''daeplotter'''
*'''In Windows:''' &lt;br /&gt;Go to: '''Start/Programs/DAE Tools/daePlotter'''
The '''daePlotter''' main window should appear (given in '''Figure 1.''')
[[Image:Screenshot-DAEPlotter.png|thumb|200px|Figure 1. daePlotter main window]]
'''daePlotter''' can be also added to a panel. Simply add a custom application launcher (command: daeplotter).

2. Start '''DAE Tools Examples''' program to try some examples:
*'''In GNU/Linux:&lt;br /&gt;'''Go to: '''Applications/Programming/DAE Tools Examples'''&lt;br /&gt;or type the following shell command: '''daeexamples'''&lt;br /&gt;
*'''In Windows:'''&lt;br /&gt;Go to: '''Start/Programs/DAE Tools/DAE Tools Examples'''
In general, simulations are started by typing the following shell commands (GNU/Linux and Windows):

&lt;syntaxhighlight lang=&quot;bash&quot;&gt;
cd &quot;directory where simulation file is located&quot;
python mySimulation.py
&lt;/syntaxhighlight&gt;

The main window of '''DAE Tools Examples''' application is given in '''Figure 2a.''' while the output from the simulation run in '''Figure 2b.''' Users can select one of several tutorials, run them, and inspect their source code or model reports. Model reports open in a new window of the system's default web browser (however, only Mozilla Firefox is currently supported because of the MathML rendering issue).

[[Image:Screenshot-DAEToolsTutorials.png|thumb|200px|Figure 2a. DAE Tools Examples main window]]

[[Image:Screenshot-DAEToolsTutorials-Run.png|thumb|200px|Figure 2b. A typical optimization output from DAE Tools]]

The simulation can also be started from the shell. The sample output is given in '''Figure 3.'''

[[Image:Screenshot-RunningSimulation.png|thumb|200px|Figure 3. Shell output from the simulation]]

== Running an optimization ==

Running the optimization problems is analogous to running a simulation.

== Modelling ==

In general, three approaches to process modelling exist &lt;ref name=&quot;Morton2003&quot;&gt;Morton, W., Equation-Oriented Simulation and Optimization. ''Proc. Indian Natl. Sci. Acad.'' 2003, 317-357.&lt;/ref&gt;:
* Sequential Modular ('''SeqM''') approach
* Simultaneous Modular ('''SimM''') approach
* Equation-Oriented ('''EO''') approach

The pros &amp; cons of the first two approaches are extensively studied in the literature. Under the '''EO''' approach we generate and gather together all equations and variables which constitute the model representing the process. The equations are solved simultaneously using a suitable mathematical algorithm &lt;ref name=&quot;Morton2003&quot; /&gt;. Equation-oriented simulation requires simultaneous solution of a set of differential algebraic equations ('''DAE''') which itself requires a solution of a set of nonlinear algebraic equations ('''NLAE''') and linear algebraic equations ('''LAE'''). The Newton's method or some variant of it is almost always used to solve problems described by NLAEs. A brief history of Equation-Oriented solvers and comparison of '''SeqM''' and '''EO''' approaches as well as descriptions of the simultaneous modular and equation-oriented methods can be found in &lt;ref name=Morton2003 /&gt;. Also a good overview of the equation-oriented approach and its application in [http://www.psenterprise.com/gproms/ gPROMS] is given by Barton &amp; Pantelides &lt;ref name=&quot;Pantelides1&quot;&gt;Pantelides, C. C., and P. I. Barton, Equation-oriented dynamic simulation current status and future perspectives, ''Computers &amp; Chemical Engineering'', vol. 17, no. Supplement 1, pp. 263 - 285, 1993.&lt;/ref&gt;, &lt;ref name=&quot;Pantelides2&quot;&gt;Barton, P. I., and C. C. Pantelides, gPROMS - a Combined Discrete/Continuous Modelling Environment for Chemical Processing Systems, ''Simulation Series'', vol. 25, no. 3, pp. 25-34, 1993. &lt;/ref&gt;, &lt;ref name=&quot;Pantelides3&quot;&gt;Barton, P. I., and C. C. Pantelides, Modeling of combined discrete/continuous processes&quot;, ''AIChE Journal'', vol. 40, pp. 966-979, 1994.&lt;/ref&gt;.

'''DAE Tools''' use the Equation-Oriented approach to process modelling, and the following types of processes can be modelled: 
* Lumped and distributed
* Steady-state and dynamic

Problems can be formulated as linear, non-linear, and (partial) differential algebraic systems (of index 1). The most common problems are initial value problems of implicit form. Equations can be ordinary or discontinuous, where discontinuities are automatically handled by the framework. A good overview of discontinuous equations and a procedure for location of equation discontinuities is given by Park &amp; Barton &lt;ref name=&quot;ParkBarton&quot;&gt;Park, T., and P. I. Barton, State event location in differential-algebraic models&quot;, ''ACM Transactions on Modeling and Computer Simulation'', vol. 6, no. 2, New York, NY, USA, ACM, pp. 137-165, 1996.&lt;/ref&gt; and in Sundials IDA [https://computation.llnl.gov/casc/sundials/documentation/ida_guide/node3.html#SECTION00330000000000000000 documentation] (used in DAE Tools).

=== Models ===

In '''DAE Tools''' models are created by defining its parameters, distribution domains, variables, equations, and ports. Models are developed by deriving a new class from the base model class ('''daeModel'''). The process consists of two steps:

# Declare all domains, parameters, variables and ports in ''__init__'' function (the constructor)
# Declare equations and state transition networks in ''DeclareEquations ''function

Models in '''pyDAE''' (using python programming language) can be defined by the following statement:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
class myModel(daeModel):
    def __init__(self, Name, Parent = None, Description = &quot;&quot;):
        daeModel.__init__(self, Name, Parent, Description)
        ... (here go declarations of domains, parameters, variables, ports, etc)

    def DeclareEquations(self):
        ... (here go declarations of equations and state transitions)
&lt;/syntaxhighlight&gt;

while in '''cDAE''' (using c++ programming language):

&lt;syntaxhighlight lang=&quot;cpp&quot;&gt;
class myModel : public daeModel
{
public:
    myModel(string strName, daeModel* pParent = NULL, string strDescription = &quot;&quot;) 
       : daeModel(strName, pParent, strDescription)
    {
        ... (here go additional properties of domains, parameters, variables, ports, etc)
    }

    void DeclareEquations(void)
    {
        ... (here go declarations of equations and state transitions)
    }

public:
    ... (here go declarations of domains, parameters, variables, ports, etc)
};
&lt;/syntaxhighlight&gt;

More information about developing models can be found in [[pydae_user_guide]] and [http://{{SERVERNAME}}/api_ref/core.html#daeModel pyDAE API Reference]. Also, do not forget to have a look on [[Tutorials|tutorials]].

=== Distribution domains ===

There are two types of domains in '''DAE Tools'''&lt;nowiki&gt;: simple arrays and distributed domains (commonly used to distribute variables, parameters and equations in space). The distributed domains can have a uniform (default) or a user specified non-uniform grid. At the moment, only the following finite difference methods can be used to calculate partial derivatives:&lt;/nowiki&gt;

* Backward finite difference method (BFD)
* Forward finite difference method (FFD)
* Center finite difference method (CFD)

In '''DAE Tools''' just anything can be distributed on domains: parameters, variables, equations even models and ports. Obviously it does not have a physical meaning to distribute a model on a domain, However that can be useful for modelling of complex processes where we can create an array of models where each point in a distributed domain have a corresponding model so that a user does not have to take care of number of points in the domain, etc. In addition, domain points values can be obtained as a '''NumPy''' one-dimensional array; this way '''DAE Tools''' can be easily used in conjuction with other scientific python libraries ([http://numpy.scipy.org/ NumPy], [http://www.scipy.org SciPy], for instance and many [http://www.scipy.org/Projects other]).

Domains in '''pyDAE''' can be defined by the following statement:
&lt;syntaxhighlight lang=&quot;python&quot;&gt;
myDomain = daeDomain(&quot;myDomain&quot;, Parent_Model_or_Port, Description)
&lt;/syntaxhighlight&gt;

while in '''cDAE''':

&lt;syntaxhighlight lang=&quot;cpp&quot;&gt;
daeDomain myDomain(&quot;myDomain&quot;, &amp;Parent_Model_or_Port, Description);
&lt;/syntaxhighlight&gt;

More information about domains can be found in [[pydae_user_guide|pyDAE User Guide]] and [http://{{SERVERNAME}}/api_ref/core.html#daeDomain pyDAE API Reference]. Also, do not forget to have a look on [[Tutorials|tutorials]].

=== Parameters ===

There are two types of parameters in '''DAE Tools''': ordinary and distributed. Several functions to get a parameter value (the function call operator) and array of values (the function ''array'') have been defined. In addition, distributed parameters have ''GetNumPyArray'' function to get the values as a numpy multi-dimensional array.

Parameters in '''pyDAE''' can be defined by the following statement:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
myParam = daeParameter(&quot;myParam&quot;, eReal, Parent_Model_or_Port, &quot;Description&quot;)
&lt;/syntaxhighlight&gt;

while in '''cDAE''':

&lt;syntaxhighlight lang=&quot;cpp&quot;&gt;
daeParameter myParam(&quot;myParam&quot;, eReal, &amp;Parent_Model_or_Port, &quot;Description&quot;);
&lt;/syntaxhighlight&gt;

More information about parameters can be found in [[PyDAE_user_guide|pyDAE User Guide]] and [http://{{SERVERNAME}}/api_ref/core.html#daeParameter pyDAE API Reference]. Also, do not forget to have a look on [[Tutorials|tutorials]].

=== Variables ===

There are two types of variables in '''DAE Tools'''&lt;nowiki&gt;: ordinary and distributed. Functions to get a variable value (function call operator), a time or a partial derivative (&lt;/nowiki&gt;''dt'', ''d'', or ''d2'') or functions to obtain an array of values, time or partial derivatives (''array, dt_array'', ''d_array'', or ''d2_array'') have been defined. In addition, distributed variables have ''GetNumPyArray'' function to get the values as a numpy multi-dimensional array''.&lt;br /&gt;''

Variables in '''pyDAE''' can be defined by the following statement:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
myVar = daeVariable(&quot;myVar&quot;, variableType, Parent_Model_or_Port, &quot;Description&quot;)
&lt;/syntaxhighlight&gt;

while in '''cDAE'''&lt;nowiki&gt;:&lt;/nowiki&gt;&lt;br /&gt;

&lt;syntaxhighlight lang=&quot;cpp&quot;&gt;
daeVariable myVar(&quot;myVar&quot;, variableType, &amp;Parent_Model_or_Port, &quot;Description&quot;);
&lt;/syntaxhighlight&gt;

More information about variables can be found in [[pydae_user_guide|pyDAE User Guide]] and [http://{{SERVERNAME}}/api_ref/core.html#daeVariable pyDAE API Reference]. Also, do not forget to have a look on [[Tutorials|tutorials]].

=== Equations ===

'''DAE Tools''' introduce two types of equations: ordinary and distributed. What makes distributed equations special is that an equation expression is valid on every point within the domains that the equations is distriibuted on. Equations can be distributed on a whole domain, on a part of it or on some of the points in a domain.&lt;br /&gt;

Equations in '''pyDAE''' can be defined by the following statement:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
eq = model.CreateEquation(&quot;myEquation&quot;, &quot;Description&quot;)
&lt;/syntaxhighlight&gt;

while in '''cDAE'''&lt;nowiki&gt;:&lt;/nowiki&gt;&lt;br /&gt;

&lt;syntaxhighlight lang=&quot;cpp&quot;&gt;
daeEquation* eq = model.CreateEquation(&quot;myEquation&quot;, &quot;Description&quot;);
&lt;/syntaxhighlight&gt;

To define an equation expression (used to calculate its residual and its gradiant - which represent a single row in a Jacobian matrix) '''DAE Tools '''combine the [http://en.wikipedia.org/wiki/Automatic_differentiation#Operator_overloading operator overloading] technique for [http://en.wikipedia.org/wiki/Automatic_differentiation automatic differentiation] (adopted from [https://projects.coin-or.org/ADOL-C '''ADOL-C'''] library) with the concept of representing equations as '''evaluation trees'''. Evaluation trees are made of binary or unary nodes, itself representing four basic mathematical operations and frequently used mathematical functions, such as sin, cos, tan, sqrt, pow, log, ln, exp, min, max, floor, ceil, abs, sum, product, ...). These basic mathematical operations and functions are implemented to operate on '''a heavily modified ADOL-C''' library class '''adouble '''(which has been extended to contain information about domains/parameters/variables etc). In adition, a new '''adouble_array '''class has been introduced to apply all above-mentioned operations on arrays of variables. What is different here is that '''adouble'''/'''adouble_array''' classes and mathematical operators/functions work in two modes; they can either '''build-up an evaluation tree''' or '''calculate a value of an expression'''. Once built the evaluation trees can be used to calculate equation residuals or derivatives to fill a Jacobian matrix necessary for a Newtown-type iteration. A typical evaluation tree is presented in '''Figure 4.''' below.

[[Image:EvaluationTree.png|thumb|200px|Figure 4. DAE Tools equation evaluation tree]]

As it has been noted before, domains, parameters, and variables contain functions that return '''adouble'''/'''adouble_array''' objects, which can be used to calculate residuals and derivatives. These functions include functions to get a value of a domain/parameter/variable (function call operator), to get a time or a partial derivative of a variable (functions ''dt'', ''d'', or ''d2'') or functions to obtain an array of values, time or partial derivatives (''array, dt_array'', ''d_array'', or ''d2_array''). Another useful feature of '''DAE Tools''' equations is that they can be exported into MathML or Latex format and easily visualized.

For example, the equation ''F'' (given in '''Figure 4.''') can be defined in '''pyDAE '''by using the following statements:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
F = model.CreateEquation(&quot;F&quot;, &quot;F description&quot;)
F.Residal = V14.dt() + V1() / (V14() + 2.5) + sin(3.14 * V3())
&lt;/syntaxhighlight&gt;

while in '''cDAE''' by:

&lt;syntaxhighlight lang=&quot;cpp&quot;&gt;
daeEquation* F = model.CreateEquation(&quot;F&quot;, &quot;F description&quot;);
F-&gt;SetResidal( V14.dt() + V1() / (V14() + 2.5) + sin(3.14 * V3()) );
&lt;/syntaxhighlight&gt;


More information about equations can be found in [[pydae_user_guide|pyDAE User Guide]] and [http://{{SERVERNAME}}/api_ref/core.html#daeEquation pyDAE API Reference]. Also, do not forget to have a look on [[Tutorials|tutorials]].

=== State Transition Networks (Discontinuous equations) ===

Discontinuous equations are equations that take different forms subject to certain conditions. For example, if we want to model a flow through a pipe we may observe three different flow regimes:

* Laminar: if Reynolds number is less than 2,100
* Transient: if Reynolds number is greater than 2,100 and less than 10,000
* Turbulent: if Reynolds number is greater than 10,000

What we can see is that from any of these three states we can go to any other state. This type of discontinuities is called a '''reversible discontinuity''' and can be described by the '''IF - ELSE_IF - ELSE''' state transient network construct. In '''pyDAE''' it is given by the following statement:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
IF(Re() &lt;= 2100)                      # (Laminar flow)
 ... (equations go here)

ELSE_IF(Re() &gt; 2100 and Re() &lt; 10000) # (Transient flow)
 ... (equations go here)

ELSE()                                # (Turbulent flow)
 ... (equations go here)

END_IF()
&lt;/syntaxhighlight&gt;

while in '''cDAE''' by:

&lt;syntaxhighlight lang=&quot;cpp&quot;&gt;
IF(Re() &lt;= 2100);                      // (Laminar flow)
 ... (equations go here)

ELSE_IF(Re() &gt; 2100 and Re() &lt; 10000); // (Transient flow)
 ... (equations go here)

ELSE();                                // (Turbulent flow)
 ... (equations go here)

END_IF();
&lt;/syntaxhighlight&gt;

'''Reversible discontinuities''' can be '''symmetrical''' and '''non-symmetrical'''. The above example is '''symmetrical'''. However, if we have a CPU and we want to model its power dissipation we may have three operating modes with the following state transitions:

* Normal mode
**switch to ''Power saving mode'' if ''CPU load'' is below 5%
**switch to ''Fried mode'' if the temperature is ''''above 110&lt;sup&gt;0&lt;/sup&gt;C
* Power saving mode
**switch to ''Normal mode'' if ''CPU load'' is above 5%
**switch to ''Fried mode'' if the temperature is ''''above 110&lt;sup&gt;0&lt;/sup&gt;C
* Fried mode (no escape from here... go to the nearest shop and buy a new one!)

What we can see is that from the ''Normal mode'' we can either go to the ''Power saving mode'' or to the ''Fried mode''. The same stands for the ''Power saving mode'': we can either go to the ''Normal mode'' or to the ''Fried mode.'' However, once the temperature exceeds 110&lt;sup&gt;0&lt;/sup&gt;C the CPU dies (let's say we heavily overclocked it) and there is no going back. This type of discontinuities is called an '''irreversible discontinuity''' and can be described by the '''STN''' state transient network construct. In '''pyDAE''' it is given by the following statement:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
STN(&quot;CPU&quot;)

STATE(&quot;Normal&quot;)
 ... (equations go here)
SWITCH_TO(&quot;PowerSaving&quot;, CPULoad() &lt; 0.05) 
SWITCH_TO(&quot;Fried&quot;, T() &gt; 110)

STATE(&quot;PowerSaving&quot;) 
 ... (equations go here)
SWITCH_TO(&quot;Normal&quot;, CPULoad() &gt;= 0.05)
SWITCH_TO(&quot;Fried&quot;, T() &gt; 110)

STATE(&quot;Normal&quot;)
 ... (equations go here)

END_STN()
&lt;/syntaxhighlight&gt;

while in '''cDAE''' by:&lt;br /&gt;

&lt;syntaxhighlight lang=&quot;cpp&quot;&gt;
STN(&quot;CPU&quot;);

STATE(&quot;Normal&quot;);
 ... (equations go here)
SWITCH_TO(&quot;PowerSaving&quot;, CPULoad() &lt; 0.05); 
SWITCH_TO(&quot;Fried&quot;, T() &gt; 110);


STATE(&quot;PowerSaving&quot;);
 ... (equations go here)
SWITCH_TO(&quot;Normal&quot;, CPULoad() &gt;= 0.05);
SWITCH_TO(&quot;Fried&quot;, T() &gt; 110);

STATE(&quot;Normal&quot;);
 ... (equations go here)

END_STN();
&lt;/syntaxhighlight&gt;

More information about state transition networks can be found in [[pydae_user_guide|pyDAE User Guide]] and [http://{{SERVERNAME}}/api_ref/core.html#daeSTN pyDAE API Reference]. Also, do not forget to have a look on [[Tutorials|tutorials]].

=== Ports ===

Ports are used to connect two models. Like models, they may contain domains, parameters and variables. For instance, in '''pyDAE''' ports can be defined by the following statements:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
class myPort(daePort):
    def __init__(self, Name, Type, Parent = None, Description = &quot;&quot;):
        daePort.__init__(self, Name, Type, Parent, Description)
        ... (here go declarations of domains, parameters and variables)
&lt;/syntaxhighlight&gt;

while in '''cDAE''' by:

&lt;syntaxhighlight lang=&quot;cpp&quot;&gt;
class myPort : public daePort
{
public:
   myPort(string strName, daeePortType eType, daeModel* pParent, string strDescription = &quot;&quot;) 
         : daePort(strName, eType, pParent, strDescription)
    {
        ... (here go additional properties of domains, parameters and variables)
    }

public:
    ... (here go declarations of domains, parameters and variables)
};
&lt;/syntaxhighlight&gt;

More information about ports can be found in [[pydae_user_guide|pyDAE User Guide]] and [http://{{SERVERNAME}}/api_ref/core.html#daePort pyDAE API Reference]. Also, do not forget to have a look on [[Tutorials|tutorials]].

== Simulation ==

As it was mentioned before, simulation of a process can be considered as the model run for certain input conditions. To define a simulation in '''DAE Tools''' the following tasks have to be done:

1. Derive a new simulation class
* Specify a model to simulate
* Specify its domains and parameters information
* Fix the degrees of freedom by assigning the values to certain variables
* Set the initial conditions for differential variables
* Set the other variables' information: initial guesses, absolute tolerances, etc
* Specify the operating procedure. It can be either a simple run for a specified period of time (default) or a complex one where various actions can be taken during the simulation

2. Specify DAE and LA solvers

3. Specify a data reporter and a data receiver, and connect them

4. Set a time horizon, reporting interval, etc

5. Do the initialization of the DAE system

6. Save model report and/or runtime model report (to inspect expanded equations etc)

7. Run the simulation

Simulations in '''pyDAE''' can be defined by the following construct:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
class mySimulation(daeSimulation):
    def __init__(self):
        daeSimulation.__init__(self)
        self.m = myModel(&quot;myModel&quot;, &quot;Description&quot;) 
          
    def SetUpParametersAndDomains(self):
        ... (here we set up domains and parameters)
    
    def SetUpVariables(self):
        ... (here we set up degrees of freedom, initial conditions, initial guesses, etc)

    def Run(self):
        ... (here goes a custom operating procedure, if needed)
&lt;/syntaxhighlight&gt;

while in '''cDAE''' by:

&lt;syntaxhighlight lang=&quot;cpp&quot;&gt;
class mySimulation : public daeSimulation
{
public:
    mySimulation(void) : m(&quot;myModel&quot;, &quot;Description&quot;)
    {
        SetModel(&amp;m);
    }

public:
    void SetUpParametersAndDomains(void)
    {
        ... (here we set up domains and parameters)
    }

    void SetUpVariables(void)
    {
        ... (here we set up degrees of freedom, initial conditions, initial guesses, etc)
    }
    
    void Run(void)
    {
        ... (here goes a custom operating procedure, if needed)
    }
    
public:
    myModel m;
};
&lt;/syntaxhighlight&gt;

=== Running a simulation ===

Simulations in '''pyDAE''' can be run in two modes:

# By using PyQt4 graphical user interface (GUI)
# From the shell

1. Running a simulation from the GUI ('''pyDAE''' only):

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
# Import modules
import sys
from time import localtime, strftime
from PyQt4 import QtCore, QtGui

# Create QtApplication object
app = QtGui.QApplication(sys.argv)

# Create simulation object
sim = simTutorial()

# Report ALL variables in the model
sim.m.SetReportingOn(True)

# Show the daeSimulator window to choose the other information needed for simulation
simulator  = daeSimulator(app, simulation=sim)
simulator.show()

# Execute applications main loop
app.exec_()
&lt;/syntaxhighlight&gt;

Here the default log, and data reporter objects will be used, while the user can choose DAE and LA solvers and specify time horizon and reporting interval.&lt;br /&gt;

2. Running a simulation from the shell:

In '''pyDAE''':

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
# Import modules
import sys
from time import localtime, strftime

# Create Log, Solver, DataReporter and Simulation object
log          = daeStdOutLog()
solver       = daeIDAS()
datareporter = daeTCPIPDataReporter()
simulation   = simTutorial()

# Set the linear solver (optional)
lasolver     = pyTrilinosAmesos.CreateTrilinosAmesosSolver(&quot;Amesos_Superlu&quot;)
solver.SetLASolver(eThirdParty, lasolver)

# Report ALL variables in the model
simulation.m.SetReportingOn(True)

# Set the time horizon (1000 seconds) and the reporting interval (10 seconds)
simulation.SetReportingInterval(10)
simulation.SetTimeHorizon(1000)

# Connect data reporter (use the default TCP/IP connection string)
simName = simulation.m.Name + strftime(&quot; [m.%Y %H:%M:%S]&quot;, localtime())
if(datareporter.Connect(&quot;&quot;, simName) == False):
    sys.exit()

# Initialize the simulation
simulation.Initialize(solver, datareporter, log)

# Solve at time = 0 (initialization)
simulation.SolveInitial()

# Run
simulation.Run()
simulation.Finalize()
&lt;/syntaxhighlight&gt;

while in '''cDAE''' by:

&lt;syntaxhighlight lang=&quot;cpp&quot;&gt;
// Create Log, Solver, DataReporter and Simulation object
boost::scoped_ptr&lt;daeSimulation_t&gt;    pSimulation(new simTutorial);  
boost::scoped_ptr&lt;daeDataReporter_t&gt;  pDataReporter(daeCreateTCPIPDataReporter());
boost::scoped_ptr&lt;daeIDASolver&gt;       pDAESolver(daeCreateIDASolver());
boost::scoped_ptr&lt;daeLog_t&gt;           pLog(daeCreateStdOutLog());

// Report ALL variables in the model
pSimulation-&gt;GetModel()-&gt;SetReportingOn(true);

// Set the time horizon and the reporting interval
pSimulation-&gt;SetReportingInterval(10);
pSimulation-&gt;SetTimeHorizon(100);
 
// Connect data reporter
string strName = pSimulation-&gt;GetModel()-&gt;GetName();
if(!pDataReporter-&gt;Connect(&quot;&quot;, strName))
    return;

// Initialize the simulation
pSimulation-&gt;Initialize(pDAESolver.get(), pDataReporter.get(), pLog.get());

// Solve at time = 0 (initialization)
pSimulation-&gt;SolveInitial();

// Run
pSimulation-&gt;Run();
pSimulation-&gt;Finalize();
&lt;/syntaxhighlight&gt;

== Optimization ==

To define an optimization problem it is first necessary to develop a model of the process and to define a simulation (as explained above). Having done these tasks (working model and simulation) the optimization in '''DAE Tools''' can be defined by specifying the objective function, optimization variables and optimization constraints. It is intentionally chosen to keep simulation and optimization tightly coupled. The optimization problem is specified in the function '''SetUpOptimization''' in the '''daeSimulation''' class. The tasks have to be done are:

1. Specify the objective function
* Objective function is defined by specifying its residual (similarly to specifying an equation residual);&lt;br /&gt; Internally the framework will create a new variable (V_obj) and a new equation (F_obj).

2. Specify optimization variables
* The optimization variables have to be already defined in the model and their values assigned in the simulation; they can be either non-distributed or distributed.
* Specify a type of optimization variable values. The variables can be '''continuous''' (floating point values in the given range), '''integer''' (set of integer values in the given range) or '''binary''' (integer value: 0 or 1).
* Specify the starting point (within the range)&lt;br /&gt;

3. Specify optimization constraints
* Two types of constraints exist in DAE Tools: '''equality''' and '''inequality''' constraints&lt;br /&gt; To define an '''equality''' constraint its residual and the value has to be specified;&lt;br /&gt; To define an '''inequality''' constraint its residual, the lower and upper bounds have to be specified;&lt;br /&gt; Internally the framework will create a new variable (V_constraint[N]) and a new equation (F_constraint[N]) for each defined constraint, where N is the ordinal number of the constraint.&lt;br /&gt;

4. Specify NLP/MINLP solver
* Currently only '''BONMIN''' MINLP solver is supported; internally it uses '''IPOPT''' NLP solver to solve NLP problems

5. Specify DAE and LA solvers

6. Specify a data reporter and a data receiver, and connect them

7. Set a time horizon, reporting interval, etc

8. Set the options of the MINLP solver

9. Initialize the optimization

10. Save model report and/or runtime model report (to inspect expanded equations etc)

11. Run the optimization

SetUpOptimization function is declared in '''pyDAE''' as the following:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
class mySimulation(daeSimulation):
    ... (here we set up a simulation)

    def SetUpOptimization(self):
        ... (here goes a declaration of the obj. function, opt. variables and constraints)
&lt;/syntaxhighlight&gt;

while in '''cDAE''' by:

&lt;syntaxhighlight lang=&quot;cpp&quot;&gt;
class mySimulation : public daeSimulation
{
    ... (here we set up a simulation)

    void SetUpOptimization(void)
    {
        ... (here goes a declaration of the obj. function, opt. variables and constraints)
    }
};
&lt;/syntaxhighlight&gt;

=== Running the optimization ===

Optimizations, like simulations in '''pyDAE''' can be run in two modes:&lt;br /&gt;

# By using PyQt4 graphical user interface (GUI)
# From the shell

1. Running an optimization from the GUI ('''pyDAE''' only):&lt;br /&gt;

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
# Import modules
import sys
from time import localtime, strftime
from PyQt4 import QtCore, QtGui

# Create QtApplication object
app = QtGui.QApplication(sys.argv)

# Create simulation object
sim = simTutorial()
nlp = daeBONMIN()

# Report ALL variables in the model
sim.m.SetReportingOn(True)

# Show the daeSimulator window to choose the other information needed for optimization
simulator = daeSimulator(app, simulation=sim, nlpsolver=nlp)
simulator.show()

# Execute applications main loop
app.exec_()
&lt;/syntaxhighlight&gt;

Here the default log, and data reporter objects will be used, while the user can choose NLP, DAE and LA solvers and specify time horizon and reporting interval.&lt;br /&gt;

2. Running a simulation from the shell:&lt;br /&gt;

In '''pyDAE'''&lt;nowiki&gt;:&lt;/nowiki&gt;&lt;br /&gt;

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
# Import modules
import sys
from time import localtime, strftime

# Create Log, NLPSolver, DAESolver, DataReporter, Simulation and Optimization objects
log          = daePythonStdOutLog()
daesolver    = daeIDAS()
nlpsolver    = daeBONMIN()
datareporter = daeTCPIPDataReporter()
simulation   = simTutorial()
optimization = daeOptimization()

# Enable reporting of all variables
simulation.m.SetReportingOn(True)

# Set the time horizon and the reporting interval
simulation.ReportingInterval = 10
simulation.TimeHorizon = 100

# Connect data reporter
simName = simulation.m.Name + strftime(&quot; [m.%Y %H:%M:%S]&quot;, localtime())
if(datareporter.Connect(&quot;&quot;, simName) == False):
    sys.exit()

# Initialize the simulation
optimization.Initialize(simulation, nlpsolver, daesolver, datareporter, log)

# Set the MINLP solver options (optional)
#nlpsolver.SetOption('OPTION', VALUE)
#nlpsolver.LoadOptionsFile(&quot;&quot;)

# Save the model report and the runtime model report 
simulation.m.SaveModelReport(simulation.m.Name + &quot;.xml&quot;)
simulation.m.SaveRuntimeModelReport(simulation.m.Name + &quot;-rt.xml&quot;)

# Run
optimization.Run()
optimization.Finalize()
&lt;/syntaxhighlight&gt;

while in '''cDAE''' by:

&lt;syntaxhighlight lang=&quot;cpp&quot;&gt;
// Create Log, NLPSolver, DAESolver, DataReporter, Simulation and Optimization objects
boost::scoped_ptr&lt;daeSimulation_t&gt;        pSimulation(new simTutorial);  
boost::scoped_ptr&lt;daeDataReporter_t&gt;      pDataReporter(daeCreateTCPIPDataReporter());
boost::scoped_ptr&lt;daeIDASolver&gt;           pDAESolver(daeCreateIDASolver());
boost::scoped_ptr&lt;daeLog_t&gt;               pLog(daeCreateStdOutLog());
boost::scoped_ptr&lt;daeNLPSolver_t&gt;         pNLPSolver(new daeBONMINSolver());
boost::scoped_ptr&lt;daeOptimization_t&gt;      pOptimization(new daeOptimization());

// Report ALL variables in the model
pSimulation-&gt;GetModel()-&gt;SetReportingOn(true);

// Set the time horizon and the reporting interval
pSimulation-&gt;SetReportingInterval(10);
pSimulation-&gt;SetTimeHorizon(100);
 
// Connect data reporter
string strName = pSimulation-&gt;GetModel()-&gt;GetName();
if(!pDataReporter-&gt;Connect(&quot;&quot;, strName))
    return;

// Initialize the simulation
pOptimization-&gt;Initialize(pSimulation.get(), 
                          pNLPSolver.get(), 
                          pDAESolver.get(), 
                          pDataReporter.get(), 
                          pLog.get());

// Run
pOptimization.Run();
pOptimization.Finalize();
&lt;/syntaxhighlight&gt;

More information about simulation can be found in [[pydae_user_guide|pyDAE User Guide]] and [http://{{SERVERNAME}}/api_ref/activity.html#daeOptimization pyDAE API Reference]. Also, do not forget to have a look on [[Tutorials|tutorials]].

== Processing the results ==

The simulation/optimization results can be easily plotted by using '''DAE Plotter''' application. It is possible to choose between 2D and 3D plots. After choosing a desired type, a '''Choose variable''' (given in '''Figure 5.''') dialog appears where a user has to select a variable to plot and specify information about domains - fix some of them while leaving another free by selecting '''&lt;nowiki&gt;*&lt;/nowiki&gt;''' from the list (to create a 2D plot you need one domain free, while for a 3D plot you need two free domains). Typical 2D and 3D plots are given in '''Figures 6. and 7.'''

[[Image:Screenshot-ChooseVariable.png|thumb|200px|Figure 5. Choose variable dialog for a 2D plot]]

[[Image:Screenshot-Results.png|thumb|200px|Figure 6. Example 2D plot (produced by Matplotlib)]]

[[Image:Screenshot-3Dplot.png|thumb|200px|Figure 7. Example 3D plot (produced by Mayavi2)]]

== References ==
&lt;references /&gt;</text>
    </revision>
  </page>
  <page>
    <title>Main Page</title>
    <id>1</id>
    <revision>
      <id>148</id>
      <timestamp>2011-04-04T17:21:02Z</timestamp>
      <contributor>
        <username>Ciroki</username>
        <id>1</id>
      </contributor>
      <comment>/* Licence */</comment>
      <text xml:space="preserve">== What is DAE Tools? ==

'''DAE Tools''' is a collection of software tools for modelling, simulation and optimization of real-world processes. Process modelling and simulation can be defined as theoretical concepts and computational methods that describe, represent in a mathematical form and simulate the functioning of real-world processes. '''DAE Tools''' is initially developed to model and simulate processes in chemical process industry (mass, heat and momentum transfers, chemical reactions, separation processes, thermodynamics). However, '''DAE Tools''' can help you develop high-accuracy models of (in general) many different kind of processes/phenomena, simulate/optimize them, visualize and analyse the results. Its features should be sufficient to enable mathematical description of chemical, physical or socio/economic phenomena. The most common are initial value problems of implicit form, which can be formulated as systems of linear, non-linear, and partial differential algebraic equations.

== News ==

=== Linear solvers ===
Several new linear equation solvers have been added. The main focus was to find and adapt a free multithreaded sparse direct solver for use with DAE Tools and it turned out that the best candidate is [http://crd.lbl.gov/~xiaoye/SuperLU/index.html SuperLU_MT]. In the next version singlethreaded and multithreaded versions of SuperLU will be the main focus of development. All the other (Trilinos Amesos, Intel Pardiso, ...) will remain there but with less or no support.

Another task is to provide support for Krylov iterative solvers and the few choices will be available in the next release: Trilinos AztecOO with IFPACK, ML or built-in preconditioners.

Finally, as the GPGPUs become more and more attractive an effort is made to try to offload computation of the most demanding tasks to GPU. The starting point is obviously a linear equation solver and two options will be offered:
* [http://code.google.com/p/cusp-library/ CUSP]
* [[SuperLU_CUDA]] (OpenMP version of SuperLU_MT modifed to work on CUDA GPU devices). The solver is still in the early development phase and the brief description is given in [[SuperLU_CUDA]]. Few issues still remain unsolved and a help from CUDA experienced developers is welcomed!  

=== NLP Solvers ===
In the next release the NLOPT optimization solvers from the [http://web.mit.edu Massachusetts Institute of Technology] will be available. More information can be found on [http://ab-initio.mit.edu/wiki/index.php/NLopt NLOPT wiki pages].

To separate NLP from MINLP problems the IPOPT is now a standalone solver.

=== Other features and bug fixes ===
All solvers support saving matrices as xpm images and matrix market files.

Few minor bug fixes.  

== The main features ==

'''DAE Tools''' is a cross-platform equation-oriented process modelling and optimization system. All core libraries are written in standard ANSI/ISO c . It is highly portable - it can run on every platform with a decent c compiler, Boost and standard c libraries (by now it is tested on 32/64 bit x86 and ARM GNU/Linux architectures making it suitable for use in embedded systems - an embedded model predictive control is a mid-term objective). '''DAE Tools''' core libraries are small and fast, and each module can be easily extended. Models can be easily developed in Python ('''pyDAE''' module) or C++ ('''cDAE''' module), compiled into an independent executable and deployed without a need for any run time libraries.

Various types of processes (lumped or distributed, steady-state or dynamic) can be modelled and optimized. They may range from very simple to those which require complex operating procedures. Equations can be ordinary or discontinuous, where discontinuities are automatically handled by the framework. Model reports  containing all information about a model can be exported in XML MathML format automatically creating a high quality documentation. The simulation results can be visualized, plotted and/or exported into various formats.

Currently [https://computation.llnl.gov/casc/sundials/main.html Sundials IDAS] solver is used to solve DAE systems and calculate sensitivities, while [https://projects.coin-or.org/Bonmin BONMIN]/[https://projects.coin-or.org/IPOPT IPOPT] set of solvers is used to solve NLP/MINLP problems. '''DAE Tools''' support direct dense and sparse matrix linear solvers (sequential and multi-threaded versions) at the moment. In addition to the built-in Sundials linear solvers, several third party libraries are interfaced: [http://software.intel.com/en-us/intel-mkl/ Intel MKL], [http://www.amd.com/acml AMD ACML], [http://trilinos.sandia.gov/packages/amesos/ Trilinos Amesos] ([http://crd.lbl.gov/~xiaoye/SuperLU/index.html SuperLU], [http://www.cise.ufl.edu/research/sparse/umfpack Umfpack], [http://www.netlib.org/lapack Lapack]/[http://math-atlas.sourceforge.net ATLAS]), which can take advantage of multi-core/cpu computers or computer clusters. BONMIN/IPOPT currently can only use [http://graal.ens-lyon.fr/MUMPS MUMPS] linear solver since it is the only one which is free. Linear solvers that exploit general-purpose graphics processing units ([http://en.wikipedia.org/wiki/GPGPU GPGPU], such as [http://www.amd.com/stream ATI Stream], and [http://www.nvidia.com/object/cuda_home_new.html NVidia CUDA]) is a short-term objective.

== Licence ==

'''DAE Tools''' is [http://www.gnu.org/ free software] and you can redistribute it and/or modify it under the terms of the [http://www.gnu.org/licenses/licenses.html#GPL GNU General Public Licence] version 3 as published by the Free Software Foundation ([http://www.gnu.org/philosophy/free-sw.html GNU philosophy]).

== History ==

''&quot;Necessity, who is the mother of invention&quot;''

''&quot;Every good work of software starts by scratching a developer's personal itch&quot;''

'''Eric S. Raymond, hacker, The Cathedral and the Bazaar, 1997'''

The latter cannot be more true&lt;ref group=&quot;note&quot; name=&quot;Raymond&quot;&gt;However, I do not agree with Eric Raymond and the Open Source Iniative views - they miss the point IMO, but let us leave it beside at the moment.&lt;/ref&gt;. The early ideas of starting a project like this go back into 2007. At that time I have been working on my PhD thesis using one of commercially available process modelling software. It was everything nice and well until I discovered some annoying bugs and lack of certain highly appreciated features. The developers of that proprietary program (as it is a case with all proprietary computer programs) had their own agenda fixing only what they wanted to fix and introducing new features that only they anticipated. Although I was able to improve the code and introduce certain features which will help (not only) me - I was helpless. The source code was not available and nobody will ever consider giving it to me to create patches with bugs fixes/new features. Not even if I swear on the holy (c++) bible!! 
Very soon the contours of a new process modelling software slowly began to form. It took me a while until I made a definite plan and initial features, and I had to abandon a couple of initial versions...

''&quot;Plan to throw one away; you will, anyhow&quot;''

'''Eric S. Raymond, hacker, The Cathedral and the Bazaar, 1997'''

Damn you Eric Raymond, interfering with my business again [[Image:smile.gif]]. 
The new project was officially born early next year - 2008.

== Acknowledgements ==

DAE Tools use the following third party free software libraries (GNU GPL or some other type of free licences):

* Sundials IDAS: [https://computation.llnl.gov/casc/sundials/main.html https://computation.llnl.gov/casc/sundials/main.html]
* Boost: [http://www.boost.org http://www.boost.org]
* ADOL-C: [https://projects.coin-or.org/ADOL-C https://projects.coin-or.org/ADOL-C]
* Qt and pyQt4: [http://qt.nokia.com Nokia], [http://www.riverbankcomputing.co.uk/software/pyqt/intro http://www.riverbankcomputing.co.uk/software/pyqt/intro]
* Numpy: [http://numpy.scipy.org http://numpy.scipy.org]
* Blas/Lapack/CLapack: [http://www.netlib.org http://www.netlib.org]
* Atlas: [http://math-atlas.sourceforge.net http://math-atlas.sourceforge.net]
* Trilinos Amesos: [http://trilinos.sandia.gov/packages/amesos/ http://trilinos.sandia.gov/packages/amesos]
* Trilinos AztecOO: [http://trilinos.sandia.gov/packages/aztecoo/ http://trilinos.sandia.gov/packages/aztecoo]
* SuperLU: [http://crd.lbl.gov/~xiaoye/SuperLU/index.html http://crd.lbl.gov/~xiaoye/SuperLU/index.html]
* Umfpack: [http://www.cise.ufl.edu/research/sparse/umfpack http://www.cise.ufl.edu/research/sparse/umfpack]
* MUMPS:  [http://graal.ens-lyon.fr/MUMPS http://graal.ens-lyon.fr/MUMPS]
* IPOPT: [https://projects.coin-or.org/Ipopt https://projects.coin-or.org/Ipopt]
* Bonmin: [https://projects.coin-or.org/Bonmin https://projects.coin-or.org/Bonmin]
* NLOPT: [http://ab-initio.mit.edu/wiki/index.php/NLopt http://ab-initio.mit.edu/wiki/index.php/NLopt]

DAE Tools can optionally use the following proprietary software libraries:

* AMD ACML linear solver (pyAmdACML module): [http://www.amd.com/acml http://www.amd.com/acml]
* Intel MKL linear solvers (pyIntelMKL and pyIntelPardiso modules): [http://software.intel.com/en-us/articles/intel-mkl http://software.intel.com/en-us/articles/intel-mkl]

Please see the corresponding websites for more details about the licences.

== How to cite ==

If you use '''DAE Tools''' in your work then please cite it in the following way: ''''' D. Nikolic, DAE Tools process modelling software, 2010. http://www.daetools.com '''''

== Footnotes ==
&lt;references group=&quot;note&quot; /&gt;</text>
    </revision>
  </page>
  <page>
    <title>News</title>
    <id>3</id>
    <revision>
      <id>176</id>
      <timestamp>2011-04-05T07:04:07Z</timestamp>
      <contributor>
        <username>Ciroki</username>
        <id>1</id>
      </contributor>
      <text xml:space="preserve">== 03.04.2011 ==
=== New Features ===

* New linear solvers:
** SuperLU
** SuperLU_MT
** SuperLU_CUDA
** CUSP

* New NLP solvers:
** [http://ab-initio.mit.edu/wiki/index.php/NLopt NLOPT]
** Standalone [http://www.coin-or.org/Ipopt IPOPT]</text>
    </revision>
  </page>
  <page>
    <title>PyDAE user guide</title>
    <id>33</id>
    <revision>
      <id>180</id>
      <timestamp>2011-04-05T07:14:22Z</timestamp>
      <contributor>
        <username>Ciroki</username>
        <id>1</id>
      </contributor>
      <comment>/* Core module */</comment>
      <text xml:space="preserve">= Core module =

== Models ==

Models have the following properties:

* '''Name''': string (read-only)&lt;br /&gt;Defines a name of an object (&quot;Temperature&quot; for instance)
* '''CanonicalName''': string (read-only)&lt;br /&gt;It is a method use to describe a location of the object (&quot;HeatExchanger.Temperature&quot; for instance means that the object Temperature belongs to the parent object HeatExchanger). Object names are separated by dot symbols (&quot;.&quot;)
* '''Description: '''string
* '''Domains''': daeDomain list
* '''Parameters''': daeParameter list
* '''Variables''': daeVariable list
* '''Equations''': daeEquation list
* '''Ports''': daePort list
* '''ChildModels''': daeModel list
* '''PortArrays''': daePortArray list
* '''ChildModelArrays''': daeModelArray list
* '''InitialConditionMode''': daeeInitialConditionMode

The most important functions are:

* '''ConnectPorts'''
* '''SetReportingOn'''
* '''sum, product, integral, average'''
* '''d, dt'''
* '''CreateEquation'''
* '''IF, ELSE_IF, ELSE, END_IF'''
* '''STN, STATE, SWITCH_TO, END_STN'''

Every user model has to implement two functions: '''__init__''' and '''DeclareEquations'''. '''__init__''' is the constructor and all parameters, distribution domains, variables, ports, and child models must be declared here. '''DeclareEquations''' function is used to declare equations and state transition networks.

Models in '''pyDAE''' can be defined by the following statement:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
class myModel(daeModel):
    def __init__(self, Name, Parent = None):
        daeModel.__init__(self, Name, Parent)
        ... (here go declarations of domains, parameters, variables, ports, etc)
    def DeclareEquations(self):
        ... (here go declarations of equations and state transitions)
&lt;/syntaxhighlight&gt;

Details of how to declare and use parameters, distribution domains, variables, ports, equations, state transition networks (STN) and child models are given in the following sections.

== Equations ==

'''DAE Tools''' introduce two types of equations: ordinary and distributed. A residual expression of distributed equations is valid on every point in distributed domains that the equations is distriibuted on. The most important equation properties are:

* '''Name''': string (read-only)
* '''CanonicalName''': string (read-only)
* '''Description: '''string
* '''Domains''': daeDomain list (read-only)
* '''Residual''': adouble

=== Declaring equations ===

The following statement is used in '''pyDAE''' to declare an ordinary equation:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
eq = model.CreateEquation(&quot;MyEquation&quot;)
&lt;/syntaxhighlight&gt;

while to declare a distributed equation the next statemets are used:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
eq = model.CreateEquation(&quot;MyEquation&quot;)
d = eq.DistributeOnDomain(myDomain, eClosedClosed)
&lt;/syntaxhighlight&gt;

Equations can be distributed on a whole domain or on a part of it. Currently there are 7 options:

* Distribute on a closed domain - analogous to: x ∈ '''[ '''x&lt;sub&gt;0&lt;/sub&gt;, x&lt;sub&gt;n&lt;/sub&gt; ''']'''
* Distribute on a left open domain - analogous to: x ∈ '''( '''x&lt;sub&gt;0&lt;/sub&gt;, x&lt;sub&gt;n&lt;/sub&gt; ''']'''
* Distribute on a right open domain - analogous to: x ∈ '''[''' x&lt;sub&gt;0&lt;/sub&gt;, x&lt;sub&gt;n&lt;/sub&gt; ''')'''
* Distribute on a domain open on both sides - analogous to: x ∈ '''(''' x&lt;sub&gt;0&lt;/sub&gt;, x&lt;sub&gt;n&lt;/sub&gt; ''')'''
* Distribute on the lower bound - only one point: x ∈ { x&lt;sub&gt;0&lt;/sub&gt; }&lt;br /&gt;This option is useful for declaring boundary conditions.
* Distribute on the upper bound - only one point: x ∈ { x&lt;sub&gt;n&lt;/sub&gt; }&lt;br /&gt;This option is useful for declaring boundary conditions.
* Custom array of points within a domain

where LB stands for the LowerBound and UB stands for the UpperBound of the domain. An overview of various bounds is given in '''Figures 1a. to 1h.'''. Here we have an equation which is distributed on two domains: '''x''' and '''y''' and we can see various available options. Green squares represent the intervals included in the distributed equation, while white squares represent excluded intervals.

[[Image:EquationBounds CC CC.png|thumb|200px|Figure 1a.&lt;br /&gt;x: eClosedClosed; y: eClosedClosed&lt;br /&gt;x ∈ [x&lt;sub&gt;0&lt;/sub&gt;, x&lt;sub&gt;n&lt;/sub&gt;], y ∈ [y&lt;sub&gt;0&lt;/sub&gt;, y&lt;sub&gt;n&lt;/sub&gt;] ]]
[[Image:EquationBounds OO OO.png|thumb|200px|Figure 1b.&lt;br /&gt;x: eOpenOpen; y: eOpenOpen&lt;br /&gt;x  ( x&lt;sub&gt;0&lt;/sub&gt;, x&lt;sub&gt;n&lt;/sub&gt; ), y ∈ ( y&lt;sub&gt;0&lt;/sub&gt;, y&lt;sub&gt;n&lt;/sub&gt; )]]
[[Image:EquationBounds CC OO.png|thumb|200px|Figure 1c.&lt;br /&gt;x: eClosedClosed; y: eOpenOpen&lt;br /&gt;x ∈ [x&lt;sub&gt;0&lt;/sub&gt;, x&lt;sub&gt;n&lt;/sub&gt;], y ∈ ( y&lt;sub&gt;0&lt;/sub&gt;, y&lt;sub&gt;n&lt;/sub&gt; ) ]]
[[Image:EquationBounds CC OC.png|thumb|200px|Figure 1d.&lt;br /&gt;x: eClosedClosed; y: eOpenClosed&lt;br /&gt;x ∈ [x&lt;sub&gt;0&lt;/sub&gt;, x&lt;sub&gt;n&lt;/sub&gt;], y ∈ ( y&lt;sub&gt;0&lt;/sub&gt;, y&lt;sub&gt;n&lt;/sub&gt; ] ]]
[[Image:EquationBounds LB CO.png|thumb|200px|Figure 1e.&lt;br /&gt;x: LB; y: eClosedOpen&lt;br /&gt;x = x&lt;sub&gt;0&lt;/sub&gt;, y ∈ [ y&lt;sub&gt;0&lt;/sub&gt;, y&lt;sub&gt;n&lt;/sub&gt; ) ]]
[[Image:EquationBounds LB CC.png|thumb|200px|Figure 1f.&lt;br /&gt;x: LB; y: eClosedClosed&lt;br /&gt;x = x&lt;sub&gt;0&lt;/sub&gt;, y ∈ [y&lt;sub&gt;0&lt;/sub&gt;, y&lt;sub&gt;n&lt;/sub&gt;] ]]
[[Image:EquationBounds UB CC.png|thumb|200px|Figure 1g.&lt;br /&gt;x: UB; y: eClosedClosed&lt;br /&gt;x = x&lt;sub&gt;n&lt;/sub&gt;, y ∈ [y&lt;sub&gt;0&lt;/sub&gt;, y&lt;sub&gt;n&lt;/sub&gt;] ]]
[[Image:EquationBounds LB UB.png|thumb|200px|Figure 1h.&lt;br /&gt;x: LB; y: UB&lt;br /&gt;x = x&lt;sub&gt;0&lt;/sub&gt;, y = y&lt;sub&gt;n&lt;/sub&gt;]]

=== Defining equations (equation residual expression) ===

The following statement can be used in '''pyDAE''' to create a residual expression of the ordinary equation:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
# Notation:
#  - V1, V3, V14 are ordinary variables
eq.Residal = V14.dt() + V1() / (V14() + 2.5) + sin(3.14 * V3())
&lt;/syntaxhighlight&gt;

The above code translates into:

&lt;math name=&quot;Eqn1&quot; /&gt;

To define a residual expression of the distributed equation the next statements can be used:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
# Notation:
#  - V1, V3 and V14 are distributed variables on domains X and Y
eq = model.CreateEquation(&quot;MyEquation&quot;)
x = eq.DistributeOnDomain(X, eClosedClosed)
y = eq.DistributeOnDomain(Y, eOpenOpen)
eq.Residal = V14.dt(x,y) + V1(x,y) / ( V14(x,y) + 2.5) + sin(3.14 * V3(x,y) )
&lt;/syntaxhighlight&gt;

The above code translates into:

&lt;math name=&quot;Eqn2&quot; /&gt;

=== Defining boundary conditions ===

Assume that we have a simple heat conduction through a very thin rectangular plate. At one side (Y = 0) we have a constant temperature (500 K) while at the opposide end we have a constant flux (1E6 W/m&lt;sup&gt;2&lt;/sup&gt;). The problem can be defined by the following statements:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
# Notation:
#  - T is a variable distributed on domains X and Y
#  - ro, k, and cp are parameters
eq = model.CreateEquation(&quot;MyEquation&quot;)
x = eq.DistributeOnDomain(X, eClosedClosed)
y = eq.DistributeOnDomain(Y, eOpenOpen)
eq.Residual = ro() * cp() * T.dt(x,y) - k() * ( T.d2(X,x,y) + T.d2(Y,x,y) )
&lt;/syntaxhighlight&gt;

We can note that the equation is defined on the domain Y, which is open on both ends. Now we have to specify the boundary conditions (2 additional equations). To do so, the following statements can be used:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
# &quot;Left&quot; boundary conditions:
lbc = model.CreateEquation(&quot;Left_BC&quot;)
x = lbc.DistributeOnDomain(X, eClosedClosed)
y = lbc.DistributeOnDomain(Y, eLowerBound)
lbc.Residal = T(x,y) - 500  # Constant temperature (500 K)
# &quot;Right&quot; boundary conditions:
rbc = model.CreateEquation(&quot;Right_BC&quot;)
x = rbc.DistributeOnDomain(X, eClosedClosed)
y = rbc.DistributeOnDomain(Y, eUpperBound)
rbc.Residal = - k() * T.d(Y,x,y) - 1E6  # Constant flux (1E6 W/m2)
&lt;/syntaxhighlight&gt;

The above statements transform into:

&lt;math name=&quot;Eqn3&quot; /&gt;

and:

&lt;math name=&quot;Eqn4&quot; /&gt;

== Distribution Domains ==

A distribution domain is a general term used to define an array of different objects. Two types of domains exist: arrays and distributed domains. Array is a synonym for a simple vector of objects. Distributed domains are most frequently used to model a spatial distribution of parameters, variables and equations, but can be equally used to spatially distribute just any other object (even ports and models). Domains have the following properties:

* '''Name''': string (read-only)
* '''CanonicalName''': string (read-only)
* '''Description: '''string
* '''Type''': daeeDomainType (read-only; array or distributed)
* '''NumberOfIntervals''': unsigned integer (read-only)
* '''NumberOfPoints''': unsigned integer (read-only)
* '''Points''': list of floats
* '''LowerBound''': float (read-only)
* '''UpperBound''': float (read-only)

Distributed domains also have:

* '''DiscretizationMethod''': daeeDiscretizationMethod (read-only)&lt;br /&gt;Currently backward finite difference ('''BFDM'''), forward finite difference ('''FFDM''') and center finite difference method ('''CFDM''') are implemented.
* '''DiscretizationOrder''': unsigned integer (read-only)&lt;br /&gt;At the moment, only the 2&lt;sup&gt;nd&lt;/sup&gt; order is supported.

There is a difference between number of points in domain and number of intervals. Number of intervals is a number of points (if it is array) or a number of finite difference elements (if it is distributed domain). Number of points is actual number of points in the domain. If it is array then they are equal. If it is distributed, and the scheme is one of finite differences for instance, it is equal to number of intervals + 1.

The most important functions are:

* '''CreateArray '''&lt;span style=&quot;font-weight: normal&quot;&gt;for creating a simple array&lt;/span&gt;
* '''CreateDistributed''' for creating a distributed array
* '''operator []''' for getting a value of the point within domain for a given index (used only to construct equation residuals)
* '''Overloaded operator ()''' for creating '''daeIndexRange''' object (used only to construct equation residuals: as an argument of functions array, dt_array, d_array, d2_array)
* '''GetNumPyArray''' for getting the point values as a numpy one-dimensional array

The process of creating domains is two-fold: first you declare a domain in the model and then you define it (by assigning its properties) in the simulation.

=== Declaring a domain ===

The following statement is used to declare a domain:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
myDomain = daeDomain(&quot;myDomain&quot;, Parent, &quot;Description&quot;)
&lt;/syntaxhighlight&gt;

=== Defining a domain ===

The following statement is used to define a distributed domain:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
# Center finite diff, 2nd order, 10 elements, Bounds: 0.0 to 1.0
myDomain.CreateDistributed(eCFDM, 2, 10, 0.0,  1.0)
&lt;/syntaxhighlight&gt;

while to define an array:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
# Array of 10 elements
myDomain.CreateArray(10)
&lt;/syntaxhighlight&gt;

=== Non-uniform grids ===

In certain situations it is not desired to have a uniform distribution of the points within the given interval (LowerBound, UpperBound). In these cases, a non-uniform grid can be specified by the following statement:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
# First create a distributed domain
myDomain.CreateDistributed(eCFDM, 2, 10, 0.0,  1.0)
# The original 11 points are: [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]
# If we are have a stiff profile at the beginning of the domain,
# then we can place more points there
myDomain.Points = [0.0, 0.05, 0.10, 0.15, 0.20, 0.25, 0.30, 0.35, 0.40, 0.60, 1.00]
&lt;/syntaxhighlight&gt;

The comparison of the effects of uniform and non-uniform grids is given in '''Figure 2.''' (a simple heat conduction problem from the Tutorial3 has been served as a basis for comparison). Here we have the following cases:

* Blue line (normal case, 10 intervals): uniform grid - a very rough prediction
* Red line (10 intervals): more points at the beginning of the domain
* Black line (100 intervals): uniform-grid (closer to the analytical solution)

[[Image:NonUniformGrid.png|thumb|200px|Figure 2. Comparison of the effects of uniform and non-uniform grids on the numerical solution]]

We can clearly observe that we get much more precise results by using denser grid at the beginning of the domain.

=== Using domains ===

'''NOTE''': It is important to understand that all functions in this section are used ONLY to construct equation residuals and NOT to access the real (raw) data.

'''I)''' To get a value of the point within the domain at the given index we can use '''operator []'''. For instance if we want variable myVar to be equal to the sixth point (indexing in python and c/c++ starts at 0) in the domain myDomain, we can write:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
# Notation:
#  - eq is a daeEquation object
#  - myDomain is daeDomain object
#  - myVar is an daeVariable object
eq.Residual = myVar() - myDomain[5]
&lt;/syntaxhighlight&gt;

The above statement translates into:

&lt;math name=&quot;Eqn5&quot; /&gt;

'''II)''' daeDomain '''operator ()''' returns the daeIndexRange object which is used as an argument of functions '''array''', '''dt_array''', '''d_array''' and '''d2_array''' in '''daeParameter''' and '''daeVariable''' classes to obtain an array of parameter/variable values, or an array of variable time (or partial) derivatives.

More details on parameter/variable arrays will be given in the following sections.

== Parameters ==

Parameters are time invariant quantities that will not change during simulation. Usually a good choice what should be a parameter is a physical constant, number of discretization points in a domain etc. Parameters have the following properties:

* '''Name''': string (read-only)
* '''CanonicalName''': string (read-only)
* '''Description: '''string
* '''Type''': daeeParameterType (read-only; real, integer, boolean)
* '''Domains''': daeDomain list

The most important functions are:

* Overloaded '''operator ()''' for getting the parameter value (used only to construct equation residuals)
* Overloaded function '''array''' for getting an array of values (used only to construct equation residuals as an argument of functions like sum, product etc)
* Overloaded functions '''SetValue''' and '''GetValue''' for access to the parameter's raw data
* '''GetNumPyArray''' for getting the values as a numpy multidimensional array

The process of creating parameters is two-fold: first you declare a parameter in the model and then you define it (by assigning its value) in the simulation.

=== Declaring a parameter ===

Parameters are declared in a model constructor ('''__init__''' function). An ordinary parameter can be declared by the following statement:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
myParam = daeParameter(&quot;myParam&quot;, eReal, Parent, &quot;Description&quot;)
&lt;/syntaxhighlight&gt;

Parameters can be distributed on domains. A distributed parameter can be declared by the next statement:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
myParam = daeParameter(&quot;myParam&quot;, eReal, Parent, &quot;Description&quot;)
myParam.DistributeOnDomain(myDomain)
&lt;/syntaxhighlight&gt;

Here, argument Parent can be either '''daeModel''' or '''daePort'''. Currently only eReal type is supported (others are ignored and used identically as the eReal type).

=== Defining a parameter ===

Parameters are defined in a simulation class ('''SetUpParametersAndDomains''' function). To set a value of an ordinary parameter:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
myParam.SetValue(1.0)
&lt;/syntaxhighlight&gt;

To set a value of distributed parameters (one-dimensional for example):

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
for i in range(0, myDomain.NumberOfPoints)
    myParam.SetValue(i, 1.0)
&lt;/syntaxhighlight&gt;

=== Using parameters ===

'''NOTE:''' It is important to understand that all functions in this section are used ONLY to construct equation residuals and NOT to access the real (raw) data.

'''I)''' To get a value of the ordinary parameter the '''operator ()''' can be used. For instance, if we want variable myVar to be equal to the sum of the value of the parameter myParam and 15, we can write the following statement:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;# Notation:
#  - eq is a daeEquation object
#  - myParam is an ordinary daeParameter object (not distributed)
#  - myVar is an ordinary daeVariable (not distributed)
eq.Residual = myVar() - myParam() - 15
&lt;/syntaxhighlight&gt;

This code translates into:

&lt;math name=&quot;Eqn6&quot; /&gt;

'''II)''' To get a value of a distributed parameter we can again use '''operator ()'''. For instance, if we want distributed variable myVar to be equal to the sum of the value of the parameter myParam and 15 at each point of the domain myDomain, we need an equation for each point in the myDomain and we can write:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
# Notation:
#  - myDomain is daeDomain object
#  - n is the number of points in the myDomain
#  - eq is a daeEquation object distributed on the myDomain
#  - d is daeDEDI object (used to iterate through the domain points)
#  - myParam is daeParameter object distributed on the myDomain
#  - myVar is daeVariable object distributed on the myDomain
d = eq.DistributeOnDomain(myDomain, eClosedClosed)
eq.Residual = myVar(d) - myParam(d) - 15
&lt;/syntaxhighlight&gt;

This code translates into n equations:

&lt;math name=&quot;Eqn7&quot; /&gt;

which is equivalent to writing (in pseudo-code):

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
for d = 0 to n:
    myVar(d) = myParam(d) + 15
&lt;/syntaxhighlight&gt;

which internally transforms into n separate equations.

Obviously, a parameter can be distributed on more than one domain. In that case we can use identical functions which accept two arguments:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
# Notation:
#  - myDomain1, myDomain2 are daeDomain objects
#  - n is the number of points in the myDomain1
#  - m is the number of points in the myDomain2
#  - eq is a daeEquation object distributed on the domains myDomain1 and myDomain2
#  - d is daeDEDI object (used to iterate through the domain points)
#  - myParam is daeParameter object distributed on the myDomain1 and myDomain2
#  - myVar is daeVariable object distributed on the myDomaina and myDomain2
d1 = eq.DistributeOnDomain(myDomain1, eClosedClosed)
d2 = eq.DistributeOnDomain(myDomain2, eClosedClosed)
eq.Residual = myVar(d1,d2) - myParam(d1,d2) - 15
&lt;/syntaxhighlight&gt;

The above statement translates into:

&lt;math name=&quot;Eqn8&quot; /&gt;

'''III)''' To get an array of parameter values we can use the function '''array''' which returns the '''adouble_array''' object. Arrays of values can only be used in conjunction with mathematical functions that operate on '''adouble_array''' objects: '''sum''', '''product''', '''sqrt''', '''sin''', '''cos''', '''min''', '''max''', '''log''', '''log10''' etc. For instance, if we want variable myVar to be equal to the sum of values of the parameter myParam for all points in the domain myDomain, we can use the function '''sum''' (defined in '''daeModel''' class) which accepts results of the '''array''' function (defined in '''daeParameter''' class). Arguments for the array function are '''daeIndexRange''' objects obtained by the call to '''daeDomain's operator ()'''. Thus, we can write the following statement:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
# Notation:
#  - myDomain is daeDomain object
#  - n is the number of points in the domain myDomain
#  - eq is daeEquation object
#  - myVar is daeVariable object
#  - myParam is daeParameter object distributed on the myDomain
eq.Residual = myVar() - sum( myParam.array( myDomain() ) )
&lt;/syntaxhighlight&gt;

This code translates into:

&lt;math name=&quot;Eqn10&quot; /&gt;

The above example could be also written in the following form:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
# points_range is daeDomainRange object
points_range = daeDomainRange(myDomain)
# arr is adouble_array object
arr = myVar2.array(points_range)
# Finally:
eq.Residual = myVar() - sum(arr)
&lt;/syntaxhighlight&gt;

On the other hand, if we want variable myVar to be equal to the sum of values of the parameter myParam only for certain points in the myDomain, there are two ways to do it:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
# Notation:
#  - myDomain is daeDomain object
#  - n is the number of points in the domain myDomain
#  - eq is a daeEquation object
#  - myVar is an ordinary daeVariable object
#  - myParam is a daeParameter object distributed on the myDomain
# 1) For a given array of points; the points must be in the range [0,n-1]
eq.Residual = myVar() - sum( myParam.array( myDomain( [0, 5, 12] ) ) )
# 2) For a given slice of points in the domain;
#    slices are defined by 3 arguments: start_index, end_index, step
#    in this example: start_index = 1
#                     end_index = 10
#                     step = 2
eq.Residual = myVar() - sum( myParam.array( myDomain(1, 10, 2) ) )
&lt;/syntaxhighlight&gt;

The code sample 1) translates into:

&lt;math name=&quot;Eqn11&quot; /&gt;

The code sample 2) translates into:

&lt;math name=&quot;Eqn12&quot; /&gt;

'''NOTE: '''One may argue that the function '''array''' calls can be somewhat simpler and directly accept python lists or slices as its arguments. For instance it would be possible to write:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
eq.Residual = myVar() - sum( myParam.array( [0, 1, 3] ) )
&lt;/syntaxhighlight&gt;

or:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
eq.Residual = myVar() - sum( myParam.array( slice(1,10,2) ) )
&lt;/syntaxhighlight&gt;

However, that would be more error prone since it does not check whether a valid domain is used for that index and whether specified indexes lay within the domain bounds (which should be done by the user).

== Variable Types ==

Variable types are used to describe variables. The most important properties are:

* '''Name''': string
* '''Units''': string
* '''LowerBound''': float
* '''UpperBound''': float
* '''InitialGuess''': float
* '''AbsoluteTolerance''': float

Declaration of variable types is usually done outside of model definitions (as global variables).

=== Declaring a variable type ===

To declare a variable type:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
# Temperature, units: Kelvin, limits: 100 - 1000K, Def.value: 273K, Abs.Tol: 1E-5
typeTemperature = daeVariableType(&quot;Temperature&quot;, &quot;K&quot;, 100, 1000, 273, 1E-5)
&lt;/syntaxhighlight&gt;

== Variables ==

Variables are time variant quantities (state variables). The most important properties are:

* '''Name''': string (read-only)
* '''CanonicalName''': string (read-only)
* '''Description: '''string
* '''Type''': daeVariableType object
* '''Domains''': daeDomain list
* '''ReportingOn''': boolean

The most important functions are:

* Overloaded '''operator ()''' for getting the variable value/time derivative/partial derivative (used only to construct equation residuals)
* Overloaded functions '''array''', '''dt_array''', '''d_array''', and '''d2_array''' for getting an array of values/time derivatives/partial derivatives (used only to construct equation residuals as an argument of functions like '''sum''', '''product''' etc)
* Overloaded functions '''AssignValue''' to fix degrees of freedom of the model
* Overloaded functions '''ReAssignValue''' to change a value of a fixed variable
* Overloaded functions '''SetValue''' and '''GetValue''' for access to the variable's raw data
* Overloaded function '''SetInitialGuess''' for setting an initial guess of the variable
* Overloaded function '''SetInitialCondition''' for setting an initial condition of the variable
* Overloaded function '''ReSetInitialCondition''' for re-setting an initial condition of the variable
* Overloaded function '''SetAbsoluteTolerances''' for setting an absolute tolerance of the variable
* '''GetNumPyArray''' for getting the values as a numpy multidimensional array

The process of creating variables is two-fold: first you declare a variable in the model and then you define it (by assigning its value) in the simulation.

=== Declaring a variable ===

Variables are declared in a model constructor ('''__init__''' function). To declare an ordinary variable:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
myVar = daeVariable(&quot;myVar&quot;, variableType, Parent, &quot;Description&quot;)
&lt;/syntaxhighlight&gt;

Variables can be distributed on domains. To declare a distributed variable:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
myVar = daeVariable(&quot;myVar&quot;, variableType, Parent, &quot;Description&quot;)
myVar.DistributeOnDomain(myDomain)
&lt;/syntaxhighlight&gt;

Here, argument Parent can be either '''daeModel''' or '''daePort'''.

=== Assigning a variable value (setting the degrees of freedom of a model) ===

Degrees of freedom can be fixed in a simulation class in '''SetUpVariables''' function by assigning the value of a variable. Assigning the value of an ordinary variables can be done by the following statement:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
myVar.AssignValue(1.0)
&lt;/syntaxhighlight&gt;

while the assigning the value of a distributed variable (one-dimensional for example) can be done by the next statement:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
for i in range(myDomain.NumberOfPoints)
    myVar.AssignValue(i, 1.0)
&lt;/syntaxhighlight&gt;

=== Re-assigning a variable value ===

Sometime during a simulation it is necessary to re-assign the variable value. This can be done by the following statement:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
myVar.ReAssignValue(1.0)
... re-assign or re-initialize some other variables too (optional)
simulation.ReInitialize()
&lt;/syntaxhighlight&gt;

'''NOTE:''' After re-assigning or after re-initializing variable(s) the function '''ReInitialize'''in the simulation object '''MUST''' be called before continuing with the simulation!

=== Accessing a variable raw data ===

Functions '''GetValue/SetValue''' access the variable raw data and should be used directly with a great care!!!

'''NOTE:''' ONLY USE THIS FUNCTION IF YOU EXACTLY KNOW WHAT ARE YOU DOING AND THE POSSIBLE IMPLICATIONS!!

Setting the value of ordinary variables can be done by the following statement::

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
myVar.SetValue(1.0)
&lt;/syntaxhighlight&gt;

while setting the value of a distributed variable can be done by:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
for i in range(myDomain.NumberOfPoints)
    myVar.SetValue(i, 1.0)
&lt;/syntaxhighlight&gt;

=== Setting an initial guess ===

Initial guesses can be set in a simulation class in '''SetUpVariables''' function. An initial guess of an ordinary variable can be set by the following statement:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
myVar.SetInitialGuess(1.0)
&lt;/syntaxhighlight&gt;

while the initial guess of a distributed variable by:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
for i in range(myDomain.NumberOfPoints)
    myVar.SetInitialGuess(i, 1.0)
&lt;/syntaxhighlight&gt;

Setting an initial guess of a distributed variable to a single value for all points in all domains can be done by the following statement:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
myVar.SetInitialGuesses(1.0)
&lt;/syntaxhighlight&gt;

=== Setting an initial condition ===

Initial conditions can be set in a simulation class in '''SetUpVariables''' function. In '''DAE Tools''' there are two modes. You can set either set an algebraic value or use the eSteadyState flag. This is controlled by the property '''InitialConditionMode''' in the simulation class (can be eAlgebraicValuesProvided or eSteadyState). '''However, only the algebraic parts can be set at the moment'''. An initial condition of an ordinary variable can be set by the following statement:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
myVar.SetInitialCondition(1.0)
&lt;/syntaxhighlight&gt;

while the initial guess of a distributed variable by:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
for i in range(myDomain.NumberOfPoints)
    myVar.SetInitialCondition(i, 1.0)
&lt;/syntaxhighlight&gt;

=== Re-setting an initial condition ===

Sometime during a simulation it is necessary to re-initialize the variable value. This can be done by the following statement:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
myVar.ReSetInitialCondition(1.0)
... re-assign or re-initialize some other variables too (optional)
simulation.ReInitialize()
&lt;/syntaxhighlight&gt;

'''NOTE:''' After re-assigning or after re-initializing the variable values the function '''ReInitialize''' in the simulation object '''MUST''' be called before continuing with the simulation!

=== Setting an absolute tolerance ===

Absolute tolerances can be set in a simulation class in '''SetUpVariables''' function by the following statement:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
myVar.SetAbsoluteTolerances(1E-5)
&lt;/syntaxhighlight&gt;

=== Getting a variable value ===

'''NOTE:''' It is important to understand that all functions in this and all following sections are used '''ONLY''' to construct equation residuals and '''NOT''' no to access the real (raw) data.

For the examples how to get a variable value see the sub-sections '''I - III''' in the section [[pydae_user_guide#Using parameters|Using parameters]]. '''Operator ()''' in '''daeVariable''' class behaves in the same way as the '''operator ()''' in '''daeParameter''' class.

=== Getting a variable time derivative ===

'''I)''' To get a time derivative of the ordinary variable the function '''dt''' can be used. For example, if we want a time derivative of the variable myVar to be equal to some constant, let's say 1.0, we can write:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
# Notation:
#  - eq is a daeEquation object
#  - myVar is an ordinary daeVariable (not distributed)
eq.Residual = myVar.dt() - 1
&lt;/syntaxhighlight&gt;

The above statement translates into:

&lt;math name=&quot;Eqn13&quot; /&gt;

'''II)''' Getting a time derivative of distributed variables is analogous to getting a parameter value (see the sub-section '''II '''in the section [[pydae_user_guide#Using Parameters]). The function '''dt''' accepts the same arguments and it is called in the same way as the '''operator ()''' in '''daeParameter''' class.

&lt;br /&gt;'''III)''' Getting an array of time derivatives of distributed variables is analogous to getting an array of parameter values (see the sub-section '''III '''in the section [[pydae_user_guide#Using Parameters]). The function '''dt_array''' accepts the same arguments and it is called in the same way as the function '''array''' in '''daeParameter''' class.

&lt;br /&gt;'''Note:''' Sometime a derivative of an expression is needed. In that case the function '''dt''' from the daeModel class can be used.

&lt;syntaxhighlight lang=&quot;python&quot;&gt;# Notation:
#  - eq is a daeEquation object
#  - myVar1 is an ordinary daeVariable (not distributed)
#  - myVar2 is an ordinary daeVariable (not distributed)
eq.Residual = model.dt( myVar1() + myVar2() )
&lt;/syntaxhighlight&gt;

=== Getting a variable partial derivative ===

It is possible to get a partial derivative only of the distributed variables and only for a domain which is distributed (not an ordinary array).

'''I)''' To get a partial derivative of the variable per some domain, we can use functions '''d''' or '''d2''' (the function d calculates a partial derivative of the first order while the function '''d2''' calculates a partial derivative of the second order). For instance, if we want a first order partial derivative of the variable '''myVar''' to be equal to some constant, let's say 1.0, we can write:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;# Notation:
#  - myDomain is daeDomain object
#  - n is the number of points in the myDomain
#  - eq is a daeEquation object distributed on the myDomain
#  - d is daeDEDI object (used to iterate through the domain points)
#  - myVar is daeVariable object distributed on the myDomain
d = eq.DistributeOnDomain(myDomain, eOpenOpen)
eq.Residual = myVar.d(myDomain, d) - 1
&lt;/syntaxhighlight&gt;

This code translates into:

&lt;math name=&quot;Eqn14&quot; /&gt;

Please note that the function myEquation is not distributed on the whole myDomain (it does not include the bounds). &lt;br /&gt;In the case we want to get a partial derivative of the second order we can use the function '''d2''' which is called in the same fashion as the function '''d''':

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
d = eq.DistributeOnDomain(myDomain, eOpenOpen)
eq.Residual = myVar.d2(myDomain, d) - 1
&lt;/syntaxhighlight&gt;

which translates into:

&lt;math name=&quot;Eqn15&quot; /&gt;

'''II)''' To get an array of partial derivatives we can use functions '''d_array''' and '''d2_array''' which return the '''adouble_array''' object (the function '''d_array''' returns an array of partial derivatives of the first order while the function '''d2_array''' returns an array of partial derivatives of the second order). Again these arrays can only be used in conjunction with mathematical functions that operate on '''adouble_array''' objects: '''sum''', '''product''', etc. For instance, if we want variable myVar to be equal to the minimal value in the array of partial derivatives of the variable myVar2 for all points in the domain myDomain, we can use the function '''min''' (defined in '''daeModel''' class) which accepts arguments of type '''adouble_array'''. Arguments for the d_array function are '''daeIndexRange '''objects obtained by the call to '''daeDomain''' '''operator ()'''. In this particular example we need a minimum among partial derivatives for the specified points (0, 1, and 3). Thus, we can write:

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
# Notation:
#  - myDomain is daeDomain object
#  - n is the number of points in the domain myDomain
#  - eq is daeEquation object
#  - myVar is daeVariable object
#  - myVar2 is daeVariable object distributed on myDomain
eq.Residual = myVar() - min( myVar2.d_array(myDomain, myDomain( [0, 1, 3] ) )
&lt;/syntaxhighlight&gt;

The above code translates into:

&lt;math name=&quot;Eqn16&quot; /&gt;

'''Note:''' Sometime a partial derivative of an expression is needed. In that case the function '''d''' from the daeModel class can be used.

&lt;syntaxhighlight lang=&quot;python&quot;&gt;
# Notation:
#  - myDomain is daeDomain object
#  - eq is a daeEquation object
#  - myVar1 is an ordinary daeVariable (not distributed)
#  - myVar2 is an ordinary daeVariable (not distributed)
eq.Residual = model.d( myVar1() + myVar2(), myDomain )
&lt;/syntaxhighlight&gt;

== Ports ==

Ports are used to connect two instances of models. Like models, ports can contain domains, parameters and variables. The most important properties are:

* '''Name''': string (read-only)
* '''CanonicalName''': string (read-only)
* '''Description: '''string
* '''Type''': daeePortType (inlet, outlet, inlet-outlet)
* '''Domains''': daeDomain list
* '''Parameters''': daeParameter list
* '''Variables''': daeVariable list

The most important functions are:

* '''SetReportingOn'''

= Activity module =

= DataReporting module =

= Solver module =</text>
    </revision>
  </page>
  <page>
    <title>SourceForge</title>
    <id>29</id>
    <revision>
      <id>50</id>
      <timestamp>2011-04-03T11:33:01Z</timestamp>
      <contributor>
        <username>Ciroki</username>
        <id>1</id>
      </contributor>
      <text xml:space="preserve">[https://sourceforge.net/projects/daetools SourceForge project home page]</text>
    </revision>
  </page>
  <page>
    <title>SuperLU CUDA</title>
    <id>30</id>
    <revision>
      <id>81</id>
      <timestamp>2011-04-04T10:20:20Z</timestamp>
      <contributor>
        <username>Ciroki</username>
        <id>1</id>
      </contributor>
      <text xml:space="preserve">This is a new DAE Tools subproject with the aim to provide a direct sparse linear equation solver which works with NVidia CUDA GPUs. Get the latest source code [http://{{SERVERNAME}}/superlu_cuda-0.0.1.tar.gz superlu_cuda-0.0.1.tar.gz].

== Current status ==

The starting point is '''test_superlu_cuda.cu''' file. Currently only functions '''get_perm_c''', '''pdgstrf_init''', '''pdgstrf''' and '''dgstrs''' are ported (not the driver functions) and all have the prefix gpu_ ('''gpu_get_perm_c''', '''gpu_pdgstrf_init''', '''gpu_pdgstrf''' and '''gpu_dgstrs''').

In superlu_cuda everything resides on a device: matrices A, B, L, U, AC etc and everything executes on the device. CUDA threads are started from the host by the function '''cuda_pdgstrf'''. Matrices are not copied back and forth from/to the device (except values for '''nzval''', '''rowind''' and '''colptr'''). The memory for '''nzval''', '''rowind''' and '''colptr''' is allocated with cudaMalloc while matrices are created with '''gpu_dCreate_CompCol_Matrix''' and '''gpu_dCreate_Dense_Matrix''' kernel calls.

The main problem is with critical sections. Currently they are implemented by using atomic operations (thanks to cvnguyen, Sarnath, tmurray and others for excelent forum posts on [http://forums.nvidia.com/index.php?s=35f6610fb56e3ab2e319eed132a93ef7&amp;showforum=62 NVidia GPU Computing]). The synchronisation points are in: '''pxgstrf_scheduler.c''' (lines 108, 275), '''pdgstrf_panel_bmod.c''' (lines 237, 282), '''pmemory.c''' (function Glu_alloc, lines 169/197 and 225/254; function DynamicSetMap lines 302/330), '''pxgstrf_synch.c''' (function NewNsuper lines 358/376). I have problems with synchronisation within warps of a block and it seems between blocks as well. Therefore I can run only one thread per warp (a group of 32 threads), so I can run on my device 512/32 = 16 threads (out of 4 SMs each with 48 cores = 192). Anyway, the additional memory for iwork and dwork arrays for a single thread is rather high (approximately 130 * N if I am correct) so not too many threads can be started anyway (for N=100 000 the memory per thread is &gt;13MB).

This is the current status. The problems are the following:
* Synchronisation between threads in a warp.
* Synchronisation between threads in different blocks.

Any help is appreciated.</text>
    </revision>
  </page>
  <page>
    <title>Tutorials</title>
    <id>32</id>
    <revision>
      <id>147</id>
      <timestamp>2011-04-04T16:35:43Z</timestamp>
      <contributor>
        <username>Ciroki</username>
        <id>1</id>
      </contributor>
      <comment>/* 0. What's the time? (AKA: Hello world!) */</comment>
      <text xml:space="preserve">'''Note: '''

Currently only Mozilla Firefox web browser is suported for viewing the model and runtime model reports (because of the MathML rendering issue).

== What's the time? (AKA: Hello world!) ==

Model report: [http://{{SERVERNAME}}/examples/whats_the_time.xml whats_the_time.xml]

Runtime model report: [http://{{SERVERNAME}}/examples/whats_the_time-rt.xml whats_the_time-rt.xml]

Source code: [http://{{SERVERNAME}}/examples/whats_the_time.html whats_the_time.py]

== Tutorial 1 ==

Model report: [http://{{SERVERNAME}}/examples/tutorial1.xml tutorial1.xml]

Runtime model report: [http://{{SERVERNAME}}/examples/tutorial1-rt.xml tutorial1-rt.xml]

Source code: [http://{{SERVERNAME}}/examples/tutorial1.html tutorial1.py]

== Tutorial 2 ==

Model report: [http://{{SERVERNAME}}/examples/tutorial2.xml tutorial2.xml]

Runtime model report: [http://{{SERVERNAME}}/examples/tutorial2-rt.xml tutorial2-rt.xml]

Source code: [http://{{SERVERNAME}}/examples/tutorial2.html tutorial2.py]

== Tutorial 3 ==

Model report: [http://{{SERVERNAME}}/examples/tutorial3.xml tutorial3.xml]

Runtime model report: [http://{{SERVERNAME}}/examples/tutorial3-rt.xml tutorial3-rt.xml]

Source code: [http://{{SERVERNAME}}/examples/tutorial3.html tutorial3.py]

== Tutorial 4 ==

Model report: [http://{{SERVERNAME}}/examples/tutorial4.xml tutorial4.xml]

Runtime model report: [http://{{SERVERNAME}}/examples/tutorial4-rt.xml tutorial4-rt.xml]

Source code: [http://{{SERVERNAME}}/examples/tutorial4.html tutorial4.py]

== Tutorial 5 ==

Model report: [http://{{SERVERNAME}}/examples/tutorial5.xml tutorial5.xml]

Runtime model report: [http://{{SERVERNAME}}/examples/tutorial5-rt.xml tutorial5-rt.xml]

Source code: [http://{{SERVERNAME}}/examples/tutorial5.html tutorial5.py]

== Tutorial 6 ==

Model report: [http://{{SERVERNAME}}/examples/tutorial6.xml tutorial6.xml]

Runtime model report: [http://{{SERVERNAME}}/examples/tutorial6-rt.xml tutorial6-rt.xml]

Source code: [http://{{SERVERNAME}}/examples/tutorial6.html tutorial6.py]

== Tutorial 7 ==

Model report: [http://{{SERVERNAME}}/examples/tutorial7.xml tutorial7.xml]

Runtime model report: [http://{{SERVERNAME}}/examples/tutorial7-rt.xml tutorial7-rt.xml]

Source code: [http://{{SERVERNAME}}/examples/tutorial7.html tutorial7.py]

== Tutorial 8 ==

Model report: [http://{{SERVERNAME}}/examples/tutorial8.xml tutorial8.xml]

Runtime model report: [http://{{SERVERNAME}}/examples/tutorial8-rt.xml tutorial8-rt.xml]

Source code: [http://{{SERVERNAME}}/examples/tutorial8.html tutorial8.py]

== Tutorial 9 ==

Model report: [http://{{SERVERNAME}}/examples/tutorial9.xml tutorial9.xml]

Runtime model report: [http://{{SERVERNAME}}/examples/tutorial9-rt.xml tutorial9-rt.xml]

Source code: [http://{{SERVERNAME}}/examples/tutorial9.html tutorial9.py]&lt;br /&gt;

== Tutorial 10 ==

Model report: [http://{{SERVERNAME}}/examples/tutorial10.xml tutorial10.xml]

Runtime model report: [http://{{SERVERNAME}}/examples/tutorial10-rt.xml tutorial10-rt.xml]

Source code: [http://{{SERVERNAME}}/examples/tutorial10.html tutorial10.py]&lt;br /&gt;

== Optimization tutorial 1 ==

Model report: [http://{{SERVERNAME}}/examples/opt_tutorial10.xml opt_tutorial1.xml]

Runtime model report: [http://{{SERVERNAME}}/examples/opt_tutorial1.xml opt_tutorial1-rt.xml]

Source code: [http://{{SERVERNAME}}/examples/opt_tutorial1.html opt_tutorial1.py]

== Optimization tutorial 2 ==

Model report: [http://{{SERVERNAME}}/examples/opt_tutorial2.xml opt_tutorial2.xml]

Runtime model report: [http://{{SERVERNAME}}/examples/opt_tutorial2.xml opt_tutorial2-rt.xml]

Source code: [http://{{SERVERNAME}}/examples/opt_tutorial2.html opt_tutorial2.py]</text>
    </revision>
  </page>
</mediawiki>
