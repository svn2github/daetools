*********************
Programming paradigms
*********************
..
    Copyright (C) Dragan Nikolic, 2013
    DAE Tools is free software; you can redistribute it and/or modify it under the
    terms of the GNU General Public License version 3 as published by the Free Software
    Foundation. DAE Tools is distributed in the hope that it will be useful, but WITHOUT
    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
    PARTICULAR PURPOSE. See the GNU General Public License for more details.
    You should have received a copy of the GNU General Public License along with the
    DAE Tools software; if not, see <http://www.gnu.org/licenses/>.

In general, there are two types of approaches that can be applied to process modelling:
Domain Specific Language approach and a general-purpose programming language approach (such as
c/c++, Java or Python). A Domain Specific Language (DSL) is a special-purpose programming or
specification language dedicated to a particular problem domain and so designed that it directly
supports the key concepts necessary to describe the underlying problems. A domain-specific
language is created specifically to solve problems in a particular domain and is usually not
intended to be able to solve problems outside it (although that may be technically possible in
some cases). In contrast, general-purpose languages are created to solve problems in a wide
variety of application domains.

Domain-specific languages are languages with very specific goals in design and implementation and
commonly lack low-level functions for filesystem access, interprocess control, and other functions
that characterize full-featured programming languages, scripting or otherwise. 

A good example of general purpose (multi-domain) domain specific language is `Modelica <http://www.modelica.org>`_
while single-domain (chemical processing industry related) DSLs are `gPROMS <http://www.psenterprise.com/gproms>`_,
`Ascend <http://ascend4.org>`_, `SpeedUp <http://www.aspentech.com>`_ etc.

**DAE Tools** approach is a sort of the hybrid approach: it applies general-purpose programming languages
such as c++ and Python, but offers a class-hierarchy/API that resembles a syntax of a DSL as much as
possible, an access to the low-level functions, large number of standard and third party libraries and
uses state of the art free/open-source software components to accomplish particular tasks (calculating
derivatives and sensitivities, solving systems of differential and algebraic systems of equations and
optimization problems, processing and plotting results etc).

.. |modelica_model| image:: _static/modelica_model.png
                     :width: 200 pt
                        
.. |gPROMS_model|   image:: _static/gPROMS_model.png
                     :width: 200 pt
                    
.. |daetools_model| image:: _static/daetools_model.png
                     :width: 320 pt

API comparison between `Modelica <http://www.modelica.org>`_, `gPROMS <http://www.psenterprise.com/gproms>`_
and **DAE Tools**:

+-----------------------+---------------------+------------------------+
+-----------------------+---------------------+------------------------+
| |modelica_model|      | |gPROMS_model|      | |daetools_model|       |
+-----------------------+---------------------+------------------------+
| **a) Modelica**       | **b) gPROMS**       | **c) DAE Tools**       |
+-----------------------+---------------------+------------------------+


**DAE Tools** provide low-level concepts such as parameters, variables, equations, ports, models,
state transition networks, discrete events etc. so that the key concepts from new application domains
can be added on top of those low level concepts. For instance, the key modelling concepts from the
simulator-independent xml-based domain specific language for modelling of biological neural
networks `NineML <http://software.incf.org/software/nineml>`_ such as neurones, synapses, connectivity
patterns, populations of neurones etc. are based on **DAE Tools** concepts.

Side-by-side comparison between the DSL approach and the **DAE Tools** hybrid approach:
    
.. list-table::
    :widths: 80 80
    :header-rows: 1

    * - **DSL Approach**
      - **DAE Tools Approach**
    * - Domain-specific languages allow solutions to be expressed in the idiom and at the level of abstraction
        of the problem domain (direct support for all modelling concepts by the language syntax)
      - Modelling concepts cannot be expressed directly in the programming language and have to be emulated in
        the API or in some other way
    * - Clean, concise, ellegant and natural way of building model descriptions: the code can be self documenting
      - The support for modelling concepts is much more verbose and less elegant; however, DAE Tools can generate
        XML+MathML based model reports that can be either rendered in XHTML format using XSLT transformations
        (representing the code documentation) or used as an XML-based model exchange language.
    * - Domain-specific languages could enhance quality, productivity, reliability, maintainability and portability
      -
    * - DSLs could be and often are simulator independent making a model exchange easier
      - Programming language dependent; however, a large number of scientific software libraries exposes its
        functionality to Python via Python wrappers
    * - Cost of designing, implementing, and maintaining a domain-specific language as well as the tools required
        to develop with it (IDE): a compiler/lexical parser/interpreter must be developed with all burden that comes
        with it (such as error handling, grammar ambiguities, hidden bugs etc)
      - A compiler/lexical parser/interpreter is an integral part of the programming language (c++, Python) with a
        robust error handling, universal grammar and massively tested
    * - Cost of learning a new language vs. its limited applicability: users are required to master a new language
        (yet another language grammar)
      - No learning of a new language required (everything can get done in a favourite programming language)
    * - Increased difficulty of integrating the DSL with other components: calling external functions/libraries and
        interaction with other software is limited by the existence of wrappers around a simulator engine
        (for instance some scripting languages like Python or javascript)
      - Calling external functions/libraries is a natural and straightforward Interaction with other software is
        natural and straightforward
    * - Models usually cannot be created in the runtime/on the fly (or at least not easily) and cannot be modified
        in the runtime
      - Models can be created in the runtime/on the fly and easily modified in the runtime
    * - Setting up a simulation (ie. the values of parameters values, initial conditions, initially active states)
        is embedded in the language and it is typically difficult to do it on the fly or to obtain the values from
        some other software (for example to chain several software calls where outputs of previous calls represent
        inputs to the subsequent ones)
      - Setting up a simulation is done programmaticaly and the initial values can be obtained from some other software
        in a natural way (chaining several software calls is easy since a large number of libraries make Python wrappers
        available)
    * - Simulation operating procedures are not flexible; manipulation of model parameters, variables, equations,
        simulation results etc is limited to only those operations provided by the language
      - Operating procedures are completely flexible (within the limits of a programming language itself) and a
        manipulation of model parameters, variables, equations, simulation results etc can be done in any way which
        a user cosiders suitable for his/her problem
    * - Only the type of results provided by the language/simulator is available; custom processing is usually not
        possible or if a simulator does provide a way to build extensions it is limited to the functionality made
        available to them
      - The results processing can be done in any way which a user considers suitable(again within the limits of a
        programming language itself)




.. image:: http://sourceforge.net/apps/piwik/daetools/piwik.php?idsite=1&amp;rec=1&amp;url=wiki/
    :alt:
