
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>6. pyDAE User Guide &mdash; DAE Tools Project 1.3.1 documentation</title>
    
    <link rel="stylesheet" href="_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1.3.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/[d][a][e].ico"/>
    <link rel="top" title="DAE Tools Project 1.3.1 documentation" href="index.html" />
    <link rel="next" title="7. pyDAE API Reference" href="pyDAE_api_ref.html" />
    <link rel="prev" title="5. Getting Started with DAE Tools" href="getting_started.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyDAE_api_ref.html" title="7. pyDAE API Reference"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="getting_started.html" title="5. Getting Started with DAE Tools"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">DAE Tools Project 1.3.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="pydae-user-guide">
<h1>6. pyDAE User Guide<a class="headerlink" href="#pydae-user-guide" title="Permalink to this headline">¶</a></h1>
<div class="section" id="importing-dae-tools-modules">
<h2>6.1. Importing DAE Tools modules<a class="headerlink" href="#importing-dae-tools-modules" title="Permalink to this headline">¶</a></h2>
<p>pyDAE modules can be imported in the following way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">daetools.pyDAE</span> <span class="kn">import</span> <span class="o">*</span>
</pre></div>
</div>
<p>This will set the python <tt class="docutils literal"><span class="pre">sys.path</span></tt> for importing the platform dependent c extension modules,
import <tt class="docutils literal"><span class="pre">pyDAE</span></tt> core modules:</p>
<ul class="simple">
<li>pyCore</li>
<li>pyActivity</li>
<li>pyDataReporting</li>
<li>pyIDAS</li>
<li>pyUnits</li>
</ul>
<p>and import platfom independent modules:</p>
<ul class="simple">
<li>logs</li>
<li>variable_types</li>
<li>dae_simulator</li>
</ul>
<p>Once the <tt class="docutils literal"><span class="pre">pyDAE</span></tt> module is imported, the other modules (such as third party linear solvers,
optimization solvers etc.) can be imported in the following way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">daetools.pyDAE</span> <span class="kn">import</span> <span class="o">*</span>

<span class="c"># Import Trilinos LA solvers (Amesos, AztecOO):</span>
<span class="kn">from</span> <span class="nn">daetools.solvers.trilinos</span> <span class="kn">import</span> <span class="n">pyTrilinos</span>

<span class="c"># Import SuperLU linear solver:</span>
<span class="kn">from</span> <span class="nn">daetools.solvers.superlu</span> <span class="kn">import</span> <span class="n">pySuperLU</span>

<span class="c"># Import SuperLU_MT linear solver:</span>
<span class="kn">from</span> <span class="nn">daetools.solvers.superlu_mt</span> <span class="kn">import</span> <span class="n">pySuperLU_MT</span>

<span class="c"># Import IPOPT NLP solver:</span>
<span class="kn">from</span> <span class="nn">daetools.solvers.ipopt</span> <span class="kn">import</span> <span class="n">pyIPOPT</span>

<span class="c"># Import BONMIN MINLP solver:</span>
<span class="kn">from</span> <span class="nn">daetools.solvers.bonmin</span> <span class="kn">import</span> <span class="n">pyBONMIN</span>

<span class="c"># Import NLOPT set of optimization solvers:</span>
<span class="kn">from</span> <span class="nn">daetools.solvers.nlopt</span> <span class="kn">import</span> <span class="n">pyNLOPT</span>
</pre></div>
</div>
<p>Since domains, parameters and variables in <strong>DAE Tools</strong> have a numerical value in terms
of a unit of measurement (<a class="reference internal" href="units.html#pyUnits.quantity" title="pyUnits.quantity"><tt class="xref py py-class docutils literal"><span class="pre">quantity</span></tt></a>) the modules containing definitions of
units and variable types must be imported. They can be imported in the following way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">variable_types</span> <span class="kn">import</span> <span class="n">length_t</span><span class="p">,</span> <span class="n">area_t</span><span class="p">,</span> <span class="n">volume_t</span>
<span class="kn">from</span> <span class="nn">pyUnits</span> <span class="kn">import</span> <span class="n">m</span><span class="p">,</span> <span class="n">kg</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">Pa</span><span class="p">,</span> <span class="n">J</span><span class="p">,</span> <span class="n">W</span>
</pre></div>
</div>
<p>For the complete list of units and variable types have a look in
<a class="reference internal" href="variable_types.html"><em>Variable types</em></a> and <a class="reference internal" href="units.html"><em>Module pyUnits</em></a> modules.</p>
</div>
<div class="section" id="developing-models">
<h2>6.2. Developing models<a class="headerlink" href="#developing-models" title="Permalink to this headline">¶</a></h2>
<p>In <strong>DAE Tools</strong> models are developed by deriving a new class from the base model class
(<a class="reference internal" href="core.html#pyCore.daeModel" title="pyCore.daeModel"><tt class="xref py py-class docutils literal"><span class="pre">pyCore.daeModel</span></tt></a>). A template/an empty model is given below:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">myModel</span><span class="p">(</span><span class="n">daeModel</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">description</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">):</span>
        <span class="n">daeModel</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">description</span><span class="p">)</span>

        <span class="c"># Declaration/instantiation of domains, parameters, variables, ports, etc:</span>
        <span class="o">...</span>

    <span class="k">def</span> <span class="nf">DeclareEquations</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c"># Declaration of equations, state transition networks etc.:</span>
        <span class="o">...</span>
</pre></div>
</div>
<p>The process consists of the following steps:</p>
<ol class="arabic">
<li><p class="first">Call the base class constructor:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">daeModel</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">description</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p class="first">Declare all domains, parameters, variables, ports, components etc. in the
<a class="reference internal" href="core.html#pyCore.daeModel.__init__" title="pyCore.daeModel.__init__"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.daeModel.__init__()</span></tt></a> function:</p>
<ul>
<li><p class="first">One of the fundamental ideas in <strong>DAE Tools</strong> is separation of the model definition
from the activities that can be carried out on that model: this way we can have one
model definition and several simulation scenarios. Consequantly, all objects are defined in
two stages:</p>
<ul class="simple">
<li>Declaration in the <a class="reference internal" href="core.html#pyCore.daeModel.__init__" title="pyCore.daeModel.__init__"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.daeModel.__init__()</span></tt></a> function</li>
<li>Initialization in the <a class="reference internal" href="activity.html#pyActivity.daeSimulation.SetUpParametersAndDomains" title="pyActivity.daeSimulation.SetUpParametersAndDomains"><tt class="xref py py-meth docutils literal"><span class="pre">pyActivity.daeSimulation.SetUpParametersAndDomains()</span></tt></a> and
<a class="reference internal" href="activity.html#pyActivity.daeSimulation.SetUpVariables" title="pyActivity.daeSimulation.SetUpVariables"><tt class="xref py py-meth docutils literal"><span class="pre">pyActivity.daeSimulation.SetUpVariables()</span></tt></a> functions.</li>
</ul>
<p>Therefore, parameters, domains and variables are only declared here, while their initialization
(setting the value, setting up the domain, assigning or setting an initial condition) is
postponed and will be done in the simulation class</p>
</li>
<li><p class="first">These objects must be declared as data members of the model since the base <a class="reference internal" href="core.html#pyCore.daeModel" title="pyCore.daeModel"><tt class="xref py py-class docutils literal"><span class="pre">pyCore.daeModel</span></tt></a>
class keeps only week references and does not own them. Therefore, use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">description</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">domain</span>    <span class="o">=</span> <span class="n">daeDomain</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">parameter</span> <span class="o">=</span> <span class="n">daeParameter</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">variable</span>  <span class="o">=</span> <span class="n">daeVariable</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="o">..</span> <span class="n">etc</span><span class="o">.</span>
</pre></div>
</div>
<p>and not:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">description</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">):</span>
    <span class="n">domain</span>    <span class="o">=</span> <span class="n">daeDomain</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">parameter</span> <span class="o">=</span> <span class="n">daeParameter</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="n">variable</span>  <span class="o">=</span> <span class="n">daeVariable</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="o">..</span> <span class="n">etc</span><span class="o">.</span>
</pre></div>
</div>
</li>
</ul>
<blockquote>
<div><p>because at the exit from the <a class="reference internal" href="core.html#pyCore.daeModel.__init__" title="pyCore.daeModel.__init__"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.daeModel.__init__()</span></tt></a> function the objects
will go out of scope and get destroyed. However, the model still holds references to them
which will result in the segmentation fault.</p>
</div></blockquote>
</li>
<li><p class="first">Declare equations, state transition networks and on_event/on_condition handlers
in the <a class="reference internal" href="core.html#pyCore.daeModel.DeclareEquations" title="pyCore.daeModel.DeclareEquations"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.daeModel.DeclareEquations()</span></tt></a> function.</p>
<ul class="simple">
<li>The <a class="reference internal" href="core.html#pyCore.daeModel.DeclareEquations" title="pyCore.daeModel.DeclareEquations"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.daeModel.DeclareEquations()</span></tt></a> function will be called automatically
by the framework. Users must not call it directly!</li>
<li>An initialization of the simulation object is done in several phases. At the point when this function
is called the model parameters, domains, variables etc. are fully initialized. Therefore, it is safe to
get the values of the parameters or domain points and use them to create equations, for example.
However, the <strong>variable values</strong> are obviously <strong>not available</strong> at this moment (for they get
initialized at the later stage). Anyway, obtaining variable values while still developing a model
is meaningless.</li>
</ul>
</li>
</ol>
<p>A simplest <strong>DAE Tools</strong> model with a description of all steps/tasks necessary to develop a model
can be found in the <a class="reference internal" href="tutorials.html#whats-the-time"><em>What&#8217;s the time? (AKA: Hello world!)</em></a> tutorial
(<a class="reference external" href="../../examples/whats_the_time.html">whats_the_time.py</a>).</p>
<div class="section" id="parameters">
<h3>6.2.1. Parameters<a class="headerlink" href="#parameters" title="Permalink to this headline">¶</a></h3>
<p>Parameters are time invariant quantities that do not change during
a simulation. Usually a good choice what should be a parameter is a
physical constant, number of discretization points in a domain etc.</p>
<p>There are two types of parameters in <strong>DAE Tools</strong>:</p>
<ul class="simple">
<li>Ordinary</li>
<li>Distributed.</li>
</ul>
<p>The process of defining parameters is two-fold:</p>
<ul class="simple">
<li>Declaring a parameter in the model</li>
<li>Initialize it (by setting its value) in the simulation</li>
</ul>
<div class="section" id="declaring-parameters">
<h4>6.2.1.1. Declaring parameters<a class="headerlink" href="#declaring-parameters" title="Permalink to this headline">¶</a></h4>
<p>Parameters are declared in the <a class="reference internal" href="core.html#pyCore.daeModel.__init__" title="pyCore.daeModel.__init__"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.daeModel.__init__()</span></tt></a> function.
An ordinary parameter can be declared in the following way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">myParam</span> <span class="o">=</span> <span class="n">daeParameter</span><span class="p">(</span><span class="s">&quot;myParam&quot;</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">parentModel</span><span class="p">,</span> <span class="s">&quot;description&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Parameters can be distributed on domains. A distributed parameter can be
declared in the following way:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">myParam</span> <span class="o">=</span> <span class="n">daeParameter</span><span class="p">(</span><span class="s">&quot;myParam&quot;</span><span class="p">,</span> <span class="n">units</span><span class="p">,</span> <span class="n">parentModel</span><span class="p">,</span> <span class="s">&quot;description&quot;</span><span class="p">)</span>
<span class="n">myParam</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">myDomain</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="initializing-parameters">
<h4>6.2.1.2. Initializing parameters<a class="headerlink" href="#initializing-parameters" title="Permalink to this headline">¶</a></h4>
<p>Parameters are initialized in the <a class="reference internal" href="activity.html#pyActivity.daeSimulation.SetUpParametersAndDomains" title="pyActivity.daeSimulation.SetUpParametersAndDomains"><tt class="xref py py-meth docutils literal"><span class="pre">pyActivity.daeSimulation.SetUpParametersAndDomains()</span></tt></a>
function. To set a value of an ordinary parameter use the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">myParam</span><span class="o">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>while to set a value of distributed parameters (one-dimensional for example) use:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">myDomain</span><span class="o">.</span><span class="n">NumberOfPoints</span><span class="p">):</span>
    <span class="n">myParam</span><span class="o">.</span><span class="n">SetValue</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>
</div>
<p>where the <tt class="docutils literal"><span class="pre">value</span></tt> can be either a <tt class="docutils literal"><span class="pre">float</span></tt> or the <a class="reference internal" href="units.html#pyUnits.quantity" title="pyUnits.quantity"><tt class="xref py py-class docutils literal"><span class="pre">pyUnits.quantity</span></tt></a> object
(for instance <tt class="docutils literal"><span class="pre">1.34</span> <span class="pre">*</span> <span class="pre">W/(m*K)</span></tt>).</p>
</div>
<div class="section" id="using-parameters">
<h4>6.2.1.3. Using parameters<a class="headerlink" href="#using-parameters" title="Permalink to this headline">¶</a></h4>
<p>The most commonly used functions are:</p>
<ul class="simple">
<li>The function call operator <a class="reference internal" href="core.html#pyCore.daeParameter.__call__" title="pyCore.daeParameter.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.daeParameter.__call__()</span></tt></a> (<tt class="docutils literal"><span class="pre">operator</span> <span class="pre">()</span></tt>)
which returns the <a class="reference internal" href="core.html#pyCore.adouble" title="pyCore.adouble"><tt class="xref py py-class docutils literal"><span class="pre">pyCore.adouble</span></tt></a> object that holds the parameter value</li>
<li>The <a class="reference internal" href="core.html#pyCore.daeParameter.array" title="pyCore.daeParameter.array"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.daeParameter.array()</span></tt></a> function which returns the <a class="reference internal" href="core.html#pyCore.adouble_array" title="pyCore.adouble_array"><tt class="xref py py-class docutils literal"><span class="pre">pyCore.adouble_array</span></tt></a>
object that holds an array of parameter values</li>
<li>Distributed parameters have the <a class="reference internal" href="core.html#pyCore.daeParameter.npyValues" title="pyCore.daeParameter.npyValues"><tt class="xref py py-attr docutils literal"><span class="pre">pyCore.daeParameter.npyValues</span></tt></a> property which
returns the parameter values as a numpy multi-dimensional array (with <tt class="docutils literal"><span class="pre">numpy.float</span></tt> data type)</li>
<li>The functions <a class="reference internal" href="core.html#pyCore.daeParameter.SetValue" title="pyCore.daeParameter.SetValue"><tt class="xref py py-class docutils literal"><span class="pre">pyCore.daeParameter.SetValue</span></tt></a> and <a class="reference internal" href="core.html#pyCore.daeParameter.GetValue" title="pyCore.daeParameter.GetValue"><tt class="xref py py-class docutils literal"><span class="pre">pyCore.daeParameter.GetValue</span></tt></a>
which get/set the parameter value as <tt class="docutils literal"><span class="pre">float</span></tt></li>
</ul>
<p><strong>Note</strong>: The functions <a class="reference internal" href="core.html#pyCore.daeParameter.__call__" title="pyCore.daeParameter.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.daeParameter.__call__()</span></tt></a> and <a class="reference internal" href="core.html#pyCore.daeParameter.array" title="pyCore.daeParameter.array"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.daeParameter.array()</span></tt></a>
can only be used in equations residual expressions. On the other hand, the functions
<a class="reference internal" href="core.html#pyCore.daeParameter.GetValue" title="pyCore.daeParameter.GetValue"><tt class="xref py py-class docutils literal"><span class="pre">pyCore.daeParameter.GetValue</span></tt></a>, <a class="reference internal" href="core.html#pyCore.daeParameter.SetValue" title="pyCore.daeParameter.SetValue"><tt class="xref py py-class docutils literal"><span class="pre">pyCore.daeParameter.SetValue</span></tt></a> and
<a class="reference internal" href="core.html#pyCore.daeParameter.npyValues" title="pyCore.daeParameter.npyValues"><tt class="xref py py-attr docutils literal"><span class="pre">pyCore.daeParameter.npyValues</span></tt></a> can be use to access the parameters real data at any point.</p>
<ol class="arabic">
<li><p class="first">To get a value of the ordinary parameter the <a class="reference internal" href="core.html#pyCore.daeParameter.__call__" title="pyCore.daeParameter.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.daeParameter.__call__()</span></tt></a>
function (<tt class="docutils literal"><span class="pre">operator</span> <span class="pre">()</span></tt>) can be used. For instance, if we want the variable <tt class="docutils literal"><span class="pre">myVar</span></tt> to be
equal to the sum of the parameter <tt class="docutils literal"><span class="pre">myParam</span></tt> and <tt class="docutils literal"><span class="pre">15</span></tt>: <img class="math" src="_images/math/519e4678f4293f3ab6d55cef233d972b7a43d657.png" alt="myVar = myParam + 15"/>,
we can write the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Notation:</span>
<span class="c">#  - eq is a daeEquation object</span>
<span class="c">#  - myParam is an ordinary daeParameter object (not distributed)</span>
<span class="c">#  - myVar is an ordinary daeVariable (not distributed)</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">myVar</span><span class="p">()</span> <span class="o">-</span> <span class="n">myParam</span><span class="p">()</span> <span class="o">-</span> <span class="mi">15</span>
</pre></div>
</div>
</li>
<li><p class="first">To get a value of a distributed parameter the <a class="reference internal" href="core.html#pyCore.daeParameter.__call__" title="pyCore.daeParameter.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.daeParameter.__call__()</span></tt></a>
function (<tt class="docutils literal"><span class="pre">operator</span> <span class="pre">()</span></tt>) can be used again. For instance, if we want the distributed
variable <tt class="docutils literal"><span class="pre">myVar</span></tt> to be equal to the sum of the parameter <tt class="docutils literal"><span class="pre">myParam</span></tt> and <tt class="docutils literal"><span class="pre">15</span></tt> at each
point of the domain <tt class="docutils literal"><span class="pre">myDomain</span></tt>: <img class="math" src="_images/math/48f6e004f2e166bd452a7cdaa4340ffb8ade3cf8.png" alt="myVar(d) = myParam(d) + 15; \forall d \in [0, d_n]"/>,
we can write:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Notation:</span>
<span class="c">#  - myDomain is daeDomain object</span>
<span class="c">#  - n is the number of points in the myDomain</span>
<span class="c">#  - eq is a daeEquation object distributed on the myDomain</span>
<span class="c">#  - d is daeDEDI object (used to iterate through the domain points)</span>
<span class="c">#  - myParam is daeParameter object distributed on the myDomain</span>
<span class="c">#  - myVar is daeVariable object distributed on the myDomain</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">myDomain</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">myVar</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">-</span> <span class="n">myParam</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">-</span> <span class="mi">15</span>
</pre></div>
</div>
<p>This code translates into <tt class="docutils literal"><span class="pre">n</span></tt> equations that is equivalent to writing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">for</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">to</span> <span class="n">n</span><span class="p">:</span>
    <span class="n">myVar</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="n">myParam</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="mi">15</span>
</pre></div>
</div>
<p>which internally transforms into <tt class="docutils literal"><span class="pre">n</span></tt> separate equations.</p>
<p>Obviously, a parameter can be distributed on more than one domain. If we want to
write an identical equation like in the previous case:
<img class="math" src="_images/math/f41b32cb546893e494eb0a8bb1d7d0a294d79380.png" alt="myVar(d_1,d_2) = myParam(d_1,d_2) + 15; \forall d_1 \in [0, d_{1n}], \forall d_2 \in [0, d_{2n}]"/>
we can write the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Notation:</span>
<span class="c">#  - myDomain1, myDomain2 are daeDomain objects</span>
<span class="c">#  - n is the number of points in the myDomain1</span>
<span class="c">#  - m is the number of points in the myDomain2</span>
<span class="c">#  - eq is a daeEquation object distributed on the domains myDomain1 and myDomain2</span>
<span class="c">#  - d is daeDEDI object (used to iterate through the domain points)</span>
<span class="c">#  - myParam is daeParameter object distributed on the myDomain1 and myDomain2</span>
<span class="c">#  - myVar is daeVariable object distributed on the myDomaina and myDomain2</span>
<span class="n">d1</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">myDomain1</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
<span class="n">d2</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">myDomain2</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">myVar</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span><span class="n">d2</span><span class="p">)</span> <span class="o">-</span> <span class="n">myParam</span><span class="p">(</span><span class="n">d1</span><span class="p">,</span><span class="n">d2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">15</span>
</pre></div>
</div>
</li>
<li><p class="first">To get an array of parameter values we can use the function
<a class="reference internal" href="core.html#pyCore.daeParameter.array" title="pyCore.daeParameter.array"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.daeParameter.array()</span></tt></a> which returns the <a class="reference internal" href="core.html#pyCore.adouble_array" title="pyCore.adouble_array"><tt class="xref py py-class docutils literal"><span class="pre">pyCore.adouble_array</span></tt></a> object.
Arrays of values can only be used in conjunction with mathematical functions that operate
on <a class="reference internal" href="core.html#pyCore.adouble_array" title="pyCore.adouble_array"><tt class="xref py py-class docutils literal"><span class="pre">pyCore.adouble_array</span></tt></a> objects such as:
<a class="reference internal" href="core.html#pyCore.Sum" title="pyCore.Sum"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.Sum()</span></tt></a>, <a class="reference internal" href="core.html#pyCore.Product" title="pyCore.Product"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.Product()</span></tt></a>, <a class="reference internal" href="core.html#pyCore.Sqrt" title="pyCore.Sqrt"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.Sqrt()</span></tt></a>, <a class="reference internal" href="core.html#pyCore.Sin" title="pyCore.Sin"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.Sin()</span></tt></a>,
<a class="reference internal" href="core.html#pyCore.Cos" title="pyCore.Cos"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.Cos()</span></tt></a>, <a class="reference internal" href="core.html#pyCore.Min" title="pyCore.Min"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.Min()</span></tt></a>, <a class="reference internal" href="core.html#pyCore.Max" title="pyCore.Max"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.Max()</span></tt></a>, <a class="reference internal" href="core.html#pyCore.Log" title="pyCore.Log"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.Log()</span></tt></a>,
<a class="reference internal" href="core.html#pyCore.Log10" title="pyCore.Log10"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.Log10()</span></tt></a>, etc.</p>
<p>For instance, if we want the variable <tt class="docutils literal"><span class="pre">myVar</span></tt> to be equal to the sum of values of the parameter
<tt class="docutils literal"><span class="pre">myParam</span></tt> for all points in the domain <tt class="docutils literal"><span class="pre">myDomain</span></tt>, we can use the function
<a class="reference internal" href="core.html#pyCore.Sum" title="pyCore.Sum"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.Sum()</span></tt></a> which accepts the <a class="reference internal" href="core.html#pyCore.adouble_array" title="pyCore.adouble_array"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.adouble_array()</span></tt></a> objects.
Arguments for the <a class="reference internal" href="core.html#pyCore.daeParameter.array" title="pyCore.daeParameter.array"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.daeParameter.array()</span></tt></a> function are <a class="reference internal" href="core.html#pyCore.daeIndexRange" title="pyCore.daeIndexRange"><tt class="xref py py-class docutils literal"><span class="pre">pyCore.daeIndexRange</span></tt></a>
objects obtained by the call to the <a class="reference internal" href="core.html#pyCore.daeDomain.__call__" title="pyCore.daeDomain.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">pyCore.daeDomain.__call__()</span></tt></a> function (<tt class="docutils literal"><span class="pre">operator</span> <span class="pre">()</span></tt>).
Thus, we can write the following:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Notation:</span>
<span class="c">#  - myDomain is daeDomain object</span>
<span class="c">#  - n is the number of points in the domain myDomain</span>
<span class="c">#  - eq is daeEquation object</span>
<span class="c">#  - myVar is daeVariable object</span>
<span class="c">#  - myParam is daeParameter object distributed on the myDomain</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">myVar</span><span class="p">()</span> <span class="o">-</span> <span class="n">Sum</span><span class="p">(</span> <span class="n">myParam</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">myDomain</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>This code translates into:
<img class="math" src="_images/math/fddab2ec00cc27f5ef67d67cd32a5a0d992acd86.png" alt="myVar = \sum myParam.array( myDomain() )"/>.</p>
<p>The above example could also be written in the following form:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># points_range is daeDomainRange object</span>
<span class="n">points_range</span> <span class="o">=</span> <span class="n">daeDomainRange</span><span class="p">(</span><span class="n">myDomain</span><span class="p">)</span>
<span class="c"># arr is adouble_array object</span>
<span class="n">arr</span> <span class="o">=</span> <span class="n">myVar2</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points_range</span><span class="p">)</span>
<span class="c"># Finally:</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">myVar</span><span class="p">()</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
</pre></div>
</div>
<p>On the other hand, if we want variable myVar to be equal to the sum of
values of the parameter myParam only for certain points in the myDomain,
there are two ways to do it:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Notation:</span>
<span class="c">#  - myDomain is daeDomain object</span>
<span class="c">#  - n is the number of points in the domain myDomain</span>
<span class="c">#  - eq is a daeEquation object</span>
<span class="c">#  - myVar is an ordinary daeVariable object</span>
<span class="c">#  - myParam is a daeParameter object distributed on the myDomain</span>
<span class="c"># 1) For a given array of points; the points must be in the range [0,n-1]</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">myVar</span><span class="p">()</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span> <span class="n">myParam</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">myDomain</span><span class="p">(</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">12</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
<span class="c"># 2) For a given slice of points in the domain;</span>
<span class="c">#    slices are defined by 3 arguments: start_index, end_index, step</span>
<span class="c">#    in this example: start_index = 1</span>
<span class="c">#                     end_index = 10</span>
<span class="c">#                     step = 2</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">myVar</span><span class="p">()</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span> <span class="n">myParam</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">myDomain</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>The code sample 1) translates into:
<img class="math" src="_images/math/be43127f0fabaf44c01651e0daf1f9ef85118709.png" alt="myVar = myParam(0) + myParam(1) + ... + myParam(n)"/></p>
<p>The code sample 2) translates into:</p>
<p><img class="math" src="_images/math/c8fa3c86b72e2728470c0dfd78c481594118514a.png" alt="myVar = myParam(0) + myParam(5) + myParam(12)"/></p>
<p>&#8216;&#8217;&#8216;NOTE: &#8216;&#8217;&#8216;One may argue that the function <cite>array</cite> calls can be
somewhat simpler and directly accept python lists or slices as its
arguments. For instance it would be possible to write:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">myVar</span><span class="p">()</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span> <span class="n">myParam</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>or:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">myVar</span><span class="p">()</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span> <span class="n">myParam</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>However, that would be more error prone since it does not check whether
a valid domain is used for that index and whether specified indexes lay
within the domain bounds (which should be done by the user).</p>
</li>
</ol>
<p>More information about parameters can be found in the API reference <a class="reference internal" href="core.html#pyCore.daeParameter" title="pyCore.daeParameter"><tt class="xref py py-class docutils literal"><span class="pre">pyCore.daeParameter</span></tt></a>
and in <a class="reference internal" href="tutorials.html"><em>Tutorials</em></a>.</p>
</div>
</div>
<div class="section" id="variables">
<h3>6.2.2. Variables<a class="headerlink" href="#variables" title="Permalink to this headline">¶</a></h3>
<p>There are two types of variables in <strong>DAE Tools</strong>: ordinary and distributed. Functions to get a variable value
(function call operator <a class="reference internal" href="core.html#pyCore.daeVariable.__call__" title="pyCore.daeVariable.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt></a>), a time or a partial derivative
(<a class="reference internal" href="core.html#pyCore.daeVariable.dt" title="pyCore.daeVariable.dt"><tt class="xref py py-meth docutils literal"><span class="pre">dt()</span></tt></a>, <a class="reference internal" href="core.html#pyCore.daeVariable.d" title="pyCore.daeVariable.d"><tt class="xref py py-meth docutils literal"><span class="pre">d()</span></tt></a>, or <a class="reference internal" href="core.html#pyCore.daeVariable.d2" title="pyCore.daeVariable.d2"><tt class="xref py py-meth docutils literal"><span class="pre">d2()</span></tt></a>) or
functions to obtain an array of values, time or partial derivatives (<a class="reference internal" href="core.html#pyCore.daeVariable.array" title="pyCore.daeVariable.array"><tt class="xref py py-meth docutils literal"><span class="pre">array()</span></tt></a>,
<a class="reference internal" href="core.html#pyCore.daeVariable.dt_array" title="pyCore.daeVariable.dt_array"><tt class="xref py py-meth docutils literal"><span class="pre">dt_array()</span></tt></a>, <a class="reference internal" href="core.html#pyCore.daeVariable.d_array" title="pyCore.daeVariable.d_array"><tt class="xref py py-meth docutils literal"><span class="pre">d_array()</span></tt></a>, or <a class="reference internal" href="core.html#pyCore.daeVariable.d2_array" title="pyCore.daeVariable.d2_array"><tt class="xref py py-meth docutils literal"><span class="pre">d2_array()</span></tt></a>)
have been defined. In addition, distributed variables have <a class="reference internal" href="core.html#pyCore.daeVariable.npyValues" title="pyCore.daeVariable.npyValues"><tt class="xref py py-attr docutils literal"><span class="pre">npyValues</span></tt></a> property to get
the values as a numpy multi-dimensional array.</p>
<p>Variables in <strong>pyDAE</strong> can be defined by the following statement:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">myVar</span> <span class="o">=</span> <span class="n">daeVariable</span><span class="p">(</span><span class="s">&quot;myVar&quot;</span><span class="p">,</span> <span class="n">variableType</span><span class="p">,</span> <span class="n">Parent_Model_or_Port</span><span class="p">,</span> <span class="s">&quot;Description&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>while in <strong>cDAE</strong>:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">daeVariable</span> <span class="n">myVar</span><span class="p">(</span><span class="s">&quot;myVar&quot;</span><span class="p">,</span> <span class="n">variableType</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Parent_Model_or_Port</span><span class="p">,</span> <span class="s">&quot;Description&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>More information about variables can be found in <a class="reference internal" href=""><em>pyDAE User Guide</em></a> and <a class="reference internal" href="core.html#pyCore.daeVariable" title="pyCore.daeVariable"><tt class="xref py py-class docutils literal"><span class="pre">pyCore.daeVariable</span></tt></a>.
Also, do not forget to have a look on <a class="reference internal" href="tutorials.html"><em>Tutorials</em></a>.</p>
</div>
<div class="section" id="distribution-domains">
<h3>6.2.3. Distribution domains<a class="headerlink" href="#distribution-domains" title="Permalink to this headline">¶</a></h3>
<p>There are two types of domains in <strong>DAE Tools</strong>: simple arrays and distributed domains (commonly used to distribute variables,
parameters and equations in space). The distributed domains can have a uniform (default) or a user specified non-uniform grid.
At the moment, only the following finite difference methods can be used to calculate partial derivatives:</p>
<ul class="simple">
<li>Backward finite difference method (BFD)</li>
<li>Forward finite difference method (FFD)</li>
<li>Center finite difference method (CFD)</li>
</ul>
<p>In <strong>DAE Tools</strong> just anything can be distributed on domains: parameters, variables, equations even models and ports.
Obviously it does not have a physical meaning to distribute a model on a domain, However that can be useful for modelling
of complex processes where we can create an array of models where each point in a distributed domain have a corresponding
model so that a user does not have to take care of number of points in the domain, etc. In addition, domain points values
can be obtained as a <strong>NumPy</strong> one-dimensional array; this way <strong>DAE Tools</strong> can be easily used in conjuction with other
scientific python libraries <a class="reference external" href="http://numpy.scipy.org">NumPy</a>, <a class="reference external" href="http://www.scipy.org">SciPy</a>, for instance and many
<a class="reference external" href="http://www.scipy.org/Projects">other</a>.</p>
<p>Domains in <strong>pyDAE</strong> can be defined by the following statement:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">myDomain</span> <span class="o">=</span> <span class="n">daeDomain</span><span class="p">(</span><span class="s">&quot;myDomain&quot;</span><span class="p">,</span> <span class="n">Parent_Model_or_Port</span><span class="p">,</span> <span class="n">Description</span><span class="p">)</span>
</pre></div>
</div>
<p>while in <strong>cDAE</strong>:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">daeDomain</span> <span class="n">myDomain</span><span class="p">(</span><span class="s">&quot;myDomain&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Parent_Model_or_Port</span><span class="p">,</span> <span class="n">Description</span><span class="p">);</span>
</pre></div>
</div>
<p>More information about domains can be found in <a class="reference internal" href=""><em>pyDAE User Guide</em></a> and <a class="reference internal" href="core.html#pyCore.daeDomain" title="pyCore.daeDomain"><tt class="xref py py-class docutils literal"><span class="pre">pyCore.daeDomain</span></tt></a>.
Also, do not forget to have a look on <a class="reference internal" href="tutorials.html"><em>Tutorials</em></a>.</p>
</div>
<div class="section" id="equations">
<h3>6.2.4. Equations<a class="headerlink" href="#equations" title="Permalink to this headline">¶</a></h3>
<p>There are three types of equations in <strong>DAE Tools</strong>:
* Ordinary
* Distributed
* Discontinuous</p>
<p>What makes distributed equations special is that an equation expression is valid on every point within
the domains that the equations is distriibuted on. Equations can be distributed on a whole domain,
on a part of it or only on some of the domain points.</p>
<p>ordinary The following statement is used in <strong>pyDAE</strong> to declare an ordinary
equation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">eq</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s">&quot;MyEquation&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>while to declare a distributed equation the next statemets are used:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">eq</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s">&quot;MyEquation&quot;</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">myDomain</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
</pre></div>
</div>
<p>Equations can be distributed on a whole domain or on a part of it.
Currently there are 7 options:</p>
<ul class="simple">
<li>Distribute on a closed domain - analogous to: x ∈ &#8216;&#8217;&#8216;[ &#8216;&#8217;&#8216;x:sub:<cite>0</cite>,
x<sub>n</sub> <strong>]</strong></li>
<li>Distribute on a left open domain - analogous to: x ∈ &#8216;&#8217;&#8216;(
&#8216;&#8217;&#8216;x:sub:<cite>0</cite>, x<sub>n</sub> <strong>]</strong></li>
<li>Distribute on a right open domain - analogous to: x ∈ <strong>[</strong>
x<sub>0</sub>, x<sub>n</sub> <strong>)</strong></li>
<li>Distribute on a domain open on both sides - analogous to: x ∈ <strong>(</strong>
x<sub>0</sub>, x<sub>n</sub> <strong>)</strong></li>
<li>Distribute on the lower bound - only one point: x ∈ { x<sub>0</sub> }
This option is useful for declaring boundary conditions.</li>
<li>Distribute on the upper bound - only one point: x ∈ { x<sub>n</sub> }
This option is useful for declaring boundary conditions.</li>
<li>Custom array of points within a domain</li>
</ul>
<p>where LB stands for the LowerBound and UB stands for the UpperBound of
the domain. An overview of various bounds is given in <strong>Figures 1a. to
1h.</strong>. Here we have an equation which is distributed on two domains:
<strong>x</strong> and <strong>y</strong> and we can see various available options. Green squares
represent the intervals included in the distributed equation, while
white squares represent excluded intervals.</p>
<div class="line-block">
<div class="line">[[Image:EquationBounds CC CC.png|thumb|200px|Figure 1a.</div>
<div class="line">x: eClosedClosed; y: eClosedClosed</div>
<div class="line">x ∈ [x:sub:<cite>0</cite>, x<sub>n</sub>], y ∈ [y:sub:<cite>0</cite>, y<sub>n</sub>] ]]</div>
</div>
<p><cite>thumb|200px|Figure 1b.
x: eOpenOpen; y: eOpenOpen
x ( x:sub:`0</cite>, x<sub>n</sub> ), y ∈ ( y<sub>0</sub>, y<sub>n</sub>
) &lt;Image:EquationBounds OO OO.png&gt;`__ [[Image:EquationBounds CC
OO.png|thumb|200px|Figure 1c.
| x: eClosedClosed; y: eOpenOpen
| x ∈ [x:sub:<cite>0</cite>, x<sub>n</sub>], y ∈ ( y<sub>0</sub>, y<sub>n</sub> ) ]]
[[Image:EquationBounds CC OC.png|thumb|200px|Figure 1d.
| x: eClosedClosed; y: eOpenClosed
| x ∈ [x:sub:<cite>0</cite>, x<sub>n</sub>], y ∈ ( y<sub>0</sub>, y<sub>n</sub> ] ]]
<cite>thumb|200px|Figure 1e.
x: LB; y: eClosedOpen
x = x:sub:`0</cite>, y ∈ [ y<sub>0</sub>, y<sub>n</sub>
) &lt;Image:EquationBounds LB CO.png&gt;`__ [[Image:EquationBounds LB
CC.png|thumb|200px|Figure 1f.
| x: LB; y: eClosedClosed
| x = x<sub>0</sub>, y ∈ [y:sub:<cite>0</cite>, y<sub>n</sub>] ]]
[[Image:EquationBounds UB CC.png|thumb|200px|Figure 1g.
| x: UB; y: eClosedClosed
| x = x<sub>n</sub>, y ∈ [y:sub:<cite>0</cite>, y<sub>n</sub>] ]] <cite>thumb|200px|Figure
1h.
x: LB; y: UB
x = x:sub:`0</cite>, y = y<sub>n</sub> &lt;Image:EquationBounds LB UB.png&gt;`__</p>
<div class="section" id="defining-equations-equation-residual-expression">
<h4>6.2.4.1. Defining equations (equation residual expression)<a class="headerlink" href="#defining-equations-equation-residual-expression" title="Permalink to this headline">¶</a></h4>
<p>The following statement can be used in <strong>pyDAE</strong> to create a residual
expression of the ordinary equation:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Notation:</span>
<span class="c">#  - V1, V3, V14 are ordinary variables</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residal</span> <span class="o">=</span> <span class="n">V14</span><span class="o">.</span><span class="n">dt</span><span class="p">()</span> <span class="o">+</span> <span class="n">V1</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">V14</span><span class="p">()</span> <span class="o">+</span> <span class="mf">2.5</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="mf">3.14</span> <span class="o">*</span> <span class="n">V3</span><span class="p">())</span>
</pre></div>
</div>
<p>The above code translates into:</p>
<p>:math:``</p>
<p>To define a residual expression of the distributed equation the next
statements can be used:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Notation:</span>
<span class="c">#  - V1, V3 and V14 are distributed variables on domains X and Y</span>
<span class="n">eq</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s">&quot;MyEquation&quot;</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">eOpenOpen</span><span class="p">)</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residal</span> <span class="o">=</span> <span class="n">V14</span><span class="o">.</span><span class="n">dt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">V1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span> <span class="n">V14</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="mf">2.5</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="mf">3.14</span> <span class="o">*</span> <span class="n">V3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>The above code translates into:</p>
<p>:math:``</p>
</div>
<div class="section" id="defining-boundary-conditions">
<h4>6.2.4.2. Defining boundary conditions<a class="headerlink" href="#defining-boundary-conditions" title="Permalink to this headline">¶</a></h4>
<p>Assume that we have a simple heat conduction through a very thin
rectangular plate. At one side (Y = 0) we have a constant temperature
(500 K) while at the opposide end we have a constant flux (1E6
W/m<sup>2</sup>). The problem can be defined by the following statements:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Notation:</span>
<span class="c">#  - T is a variable distributed on domains X and Y</span>
<span class="c">#  - ro, k, and cp are parameters</span>
<span class="n">eq</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s">&quot;MyEquation&quot;</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">eq</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">eOpenOpen</span><span class="p">)</span>
<span class="n">eq</span><span class="o">.</span><span class="n">Residual</span> <span class="o">=</span> <span class="n">ro</span><span class="p">()</span> <span class="o">*</span> <span class="n">cp</span><span class="p">()</span> <span class="o">*</span> <span class="n">T</span><span class="o">.</span><span class="n">dt</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span> <span class="n">T</span><span class="o">.</span><span class="n">d2</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">T</span><span class="o">.</span><span class="n">d2</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="p">)</span>
</pre></div>
</div>
<p>We can note that the equation is defined on the domain Y, which is open
on both ends. Now we have to specify the boundary conditions (2
additional equations). To do so, the following statements can be used:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># &quot;Left&quot; boundary conditions:</span>
<span class="n">lbc</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s">&quot;Left_BC&quot;</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">lbc</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">lbc</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">eLowerBound</span><span class="p">)</span>
<span class="n">lbc</span><span class="o">.</span><span class="n">Residal</span> <span class="o">=</span> <span class="n">T</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="mi">500</span>  <span class="c"># Constant temperature (500 K)</span>
<span class="c"># &quot;Right&quot; boundary conditions:</span>
<span class="n">rbc</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s">&quot;Right_BC&quot;</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">rbc</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">eClosedClosed</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">rbc</span><span class="o">.</span><span class="n">DistributeOnDomain</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span> <span class="n">eUpperBound</span><span class="p">)</span>
<span class="n">rbc</span><span class="o">.</span><span class="n">Residal</span> <span class="o">=</span> <span class="o">-</span> <span class="n">k</span><span class="p">()</span> <span class="o">*</span> <span class="n">T</span><span class="o">.</span><span class="n">d</span><span class="p">(</span><span class="n">Y</span><span class="p">,</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="mf">1E6</span>  <span class="c"># Constant flux (1E6 W/m2)</span>
</pre></div>
</div>
<p>The above statements transform into:</p>
<p>:math:``</p>
<p>and:</p>
<p>:math:``</p>
<p><strong>DAE Tools</strong> introduce two types of equations: ordinary and distributed. What makes distributed
equations special is that an equation expression is valid on every point within the domains that
the equations is distriibuted on. Equations can be distributed on a whole domain, on a part of it
or on some of the points in a domain. Equations in <strong>pyDAE</strong> can be defined by the following statement:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">eq</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s">&quot;myEquation&quot;</span><span class="p">,</span> <span class="s">&quot;Description&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>while in <strong>cDAE</strong>:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">daeEquation</span><span class="o">*</span> <span class="n">eq</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s">&quot;myEquation&quot;</span><span class="p">,</span> <span class="s">&quot;Description&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>To define an equation expression (used to calculate its residual and its gradient - which represent a single row in a
Jacobian matrix) <strong>DAE Tools</strong> combine the
<a class="reference external" href="http://en.wikipedia.org/wiki/Automatic_differentiation#Operator_overloading">operator overloading</a>
technique for <a class="reference external" href="http://en.wikipedia.org/wiki/Automatic_differentiation">automatic differentiation</a>
(adopted from <a class="reference external" href="https://projects.coin-or.org/ADOL-C">ADOL-C</a> library) with the concept of representing equations as
<strong>evaluation trees</strong>. Evaluation trees are made of binary or unary nodes, itself representing four basic mathematical
operations and frequently used mathematical functions, such as <tt class="docutils literal"><span class="pre">sin,</span> <span class="pre">cos,</span> <span class="pre">tan,</span> <span class="pre">sqrt,</span> <span class="pre">pow,</span> <span class="pre">log,</span> <span class="pre">ln,</span> <span class="pre">exp,</span> <span class="pre">min,</span> <span class="pre">max,</span> <span class="pre">floor,</span> <span class="pre">ceil,</span>
<span class="pre">abs,</span> <span class="pre">sum,</span> <span class="pre">product,</span> <span class="pre">...</span></tt>. These basic mathematical operations and functions are implemented to operate on <strong>a heavily
modified ADOL-C</strong> library class <a class="reference internal" href="core.html#pyCore.adouble" title="pyCore.adouble"><tt class="xref py py-class docutils literal"><span class="pre">adouble</span></tt></a> (which has been extended to contain information about
domains/parameters/variables etc). In adition, a new <a class="reference internal" href="core.html#pyCore.adouble_array" title="pyCore.adouble_array"><tt class="xref py py-class docutils literal"><span class="pre">adouble_array</span></tt></a> class has been introduced to apply all
above-mentioned operations on arrays of variables.
What is different here is that <a class="reference internal" href="core.html#pyCore.adouble" title="pyCore.adouble"><tt class="xref py py-class docutils literal"><span class="pre">adouble</span></tt></a>/<a class="reference internal" href="core.html#pyCore.adouble_array" title="pyCore.adouble_array"><tt class="xref py py-class docutils literal"><span class="pre">adouble_array</span></tt></a> classes and mathematical
operators/functions work in two modes; they can either <strong>build-up an evaluation tree</strong> or <strong>calculate a value of an expression</strong>.
Once built the evaluation trees can be used to calculate equation residuals or derivatives to fill a Jacobian matrix
necessary for a Newton-type iteration. A typical evaluation tree is presented in <a class="reference internal" href="#figure-4"><em>Figure 4.</em></a>.</p>
<div class="figure" id="figure-4">
<img alt="_images/EvaluationTree.png" src="_images/EvaluationTree.png" />
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">width:</th><td class="field-body">250 pt</td>
</tr>
<tr class="field-even field"><th class="field-name">figwidth:</th><td class="field-body">300 pt</td>
</tr>
<tr class="field-odd field"><th class="field-name">align:</th><td class="field-body">center</td>
</tr>
</tbody>
</table>
<p><strong>Figure 4.</strong> DAE Tools equation evaluation tree</p>
<p>As it has been noted before, domains, parameters, and variables contain functions that return
<a class="reference internal" href="core.html#pyCore.adouble" title="pyCore.adouble"><tt class="xref py py-class docutils literal"><span class="pre">adouble</span></tt></a>/<a class="reference internal" href="core.html#pyCore.adouble_array" title="pyCore.adouble_array"><tt class="xref py py-class docutils literal"><span class="pre">adouble_array</span></tt></a> objects, which can be used to calculate
residuals and derivatives. These functions include functions to get a value of
a domain/parameter/variable (function call operator), to get a time or a partial derivative of a variable
(functions <a class="reference internal" href="core.html#pyCore.daeVariable.dt" title="pyCore.daeVariable.dt"><tt class="xref py py-meth docutils literal"><span class="pre">dt()</span></tt></a>, <a class="reference internal" href="core.html#pyCore.daeVariable.d" title="pyCore.daeVariable.d"><tt class="xref py py-meth docutils literal"><span class="pre">d()</span></tt></a>, or <a class="reference internal" href="core.html#pyCore.daeVariable.d2" title="pyCore.daeVariable.d2"><tt class="xref py py-meth docutils literal"><span class="pre">d2()</span></tt></a>)
or functions to obtain an array of values, time or partial derivatives (<a class="reference internal" href="core.html#pyCore.daeVariable.array" title="pyCore.daeVariable.array"><tt class="xref py py-meth docutils literal"><span class="pre">array()</span></tt></a>,
<a class="reference internal" href="core.html#pyCore.daeVariable.dt_array" title="pyCore.daeVariable.dt_array"><tt class="xref py py-meth docutils literal"><span class="pre">dt_array()</span></tt></a>, <a class="reference internal" href="core.html#pyCore.daeVariable.d_array" title="pyCore.daeVariable.d_array"><tt class="xref py py-meth docutils literal"><span class="pre">d_array()</span></tt></a>, or <a class="reference internal" href="core.html#pyCore.daeVariable.d2_array" title="pyCore.daeVariable.d2_array"><tt class="xref py py-meth docutils literal"><span class="pre">d2_array()</span></tt></a>).
Another useful feature of <strong>DAE Tools</strong> equations is that they can be
exported into MathML or Latex format and easily visualized.</p>
<p>For example, the equation <em>F</em> (given in <a class="reference internal" href="#figure-4"><em>Figure 4.</em></a>) can be defined in <strong>pyDAE</strong> by using the following
statements:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">F</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s">&quot;F&quot;</span><span class="p">,</span> <span class="s">&quot;F description&quot;</span><span class="p">)</span>
<span class="n">F</span><span class="o">.</span><span class="n">Residal</span> <span class="o">=</span> <span class="n">V14</span><span class="o">.</span><span class="n">dt</span><span class="p">()</span> <span class="o">+</span> <span class="n">V1</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">V14</span><span class="p">()</span> <span class="o">+</span> <span class="mf">2.5</span><span class="p">)</span> <span class="o">+</span> <span class="n">Sin</span><span class="p">(</span><span class="mf">3.14</span> <span class="o">*</span> <span class="n">V3</span><span class="p">())</span>
</pre></div>
</div>
<p>while in <strong>cDAE</strong> by:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">daeEquation</span><span class="o">*</span> <span class="n">F</span> <span class="o">=</span> <span class="n">model</span><span class="p">.</span><span class="n">CreateEquation</span><span class="p">(</span><span class="s">&quot;F&quot;</span><span class="p">,</span> <span class="s">&quot;F description&quot;</span><span class="p">);</span>
<span class="n">F</span><span class="o">-&gt;</span><span class="n">SetResidal</span><span class="p">(</span> <span class="n">V14</span><span class="p">.</span><span class="n">dt</span><span class="p">()</span> <span class="o">+</span> <span class="n">V1</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="n">V14</span><span class="p">()</span> <span class="o">+</span> <span class="mf">2.5</span><span class="p">)</span> <span class="o">+</span> <span class="n">sin</span><span class="p">(</span><span class="mf">3.14</span> <span class="o">*</span> <span class="n">V3</span><span class="p">())</span> <span class="p">);</span>
</pre></div>
</div>
<p>More information about equations can be found in <a class="reference internal" href=""><em>pyDAE User Guide</em></a> and <a class="reference internal" href="core.html#pyCore.daeEquation" title="pyCore.daeEquation"><tt class="xref py py-class docutils literal"><span class="pre">pyCore.daeEquation</span></tt></a>.
Also, do not forget to have a look on <a class="reference internal" href="tutorials.html"><em>Tutorials</em></a>.</p>
</div>
</div>
<div class="section" id="state-transition-networks">
<h3>6.2.5. State Transition Networks<a class="headerlink" href="#state-transition-networks" title="Permalink to this headline">¶</a></h3>
<p>Discontinuous equations are equations that take different forms subject to certain conditions. For example,
if we want to model a flow through a pipe we may observe three different flow regimes:</p>
<ul class="simple">
<li>Laminar: if Reynolds number is less than 2,100</li>
<li>Transient: if Reynolds number is greater than 2,100 and less than 10,000</li>
<li>Turbulent: if Reynolds number is greater than 10,000</li>
</ul>
<p>What we can see is that from any of these three states we can go to any other state. This type of discontinuities
is called a <strong>reversible discontinuity</strong> and can be described by the
<a class="reference internal" href="core.html#pyCore.daeModel.IF" title="pyCore.daeModel.IF"><tt class="xref py py-meth docutils literal"><span class="pre">IF()</span></tt></a>, <a class="reference internal" href="core.html#pyCore.daeModel.ELSE_IF" title="pyCore.daeModel.ELSE_IF"><tt class="xref py py-meth docutils literal"><span class="pre">ELSE_IF()</span></tt></a>, <a class="reference internal" href="core.html#pyCore.daeModel.ELSE" title="pyCore.daeModel.ELSE"><tt class="xref py py-meth docutils literal"><span class="pre">ELSE()</span></tt></a>
state transient network functions.
In <strong>pyDAE</strong> it is given by the following statement:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">IF</span><span class="p">(</span><span class="n">Re</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">2100</span><span class="p">)</span>                      <span class="c"># (Laminar flow)</span>
<span class="c">#... (equations go here)</span>

<span class="n">ELSE_IF</span><span class="p">(</span><span class="n">Re</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2100</span> <span class="ow">and</span> <span class="n">Re</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">)</span> <span class="c"># (Transient flow)</span>
<span class="c">#... (equations go here)</span>

<span class="n">ELSE</span><span class="p">()</span>                                <span class="c"># (Turbulent flow)</span>
<span class="c">#... (equations go here)</span>

<span class="n">END_IF</span><span class="p">()</span>
</pre></div>
</div>
<p>while in <strong>cDAE</strong> by:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">IF</span><span class="p">(</span><span class="n">Re</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">2100</span><span class="p">);</span>                      <span class="c1">// (Laminar flow)</span>
<span class="c1">//... (equations go here)</span>

<span class="n">ELSE_IF</span><span class="p">(</span><span class="n">Re</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">2100</span> <span class="o">&amp;&amp;</span> <span class="n">Re</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">);</span>  <span class="c1">// (Transient flow)</span>
<span class="c1">//... (equations go here)</span>

<span class="n">ELSE</span><span class="p">();</span>                                <span class="c1">// (Turbulent flow)</span>
<span class="c1">//... (equations go here)</span>

<span class="n">END_IF</span><span class="p">();</span>
</pre></div>
</div>
<p><strong>Reversible discontinuities</strong> can be <strong>symmetrical</strong> and <strong>non-symmetrical</strong>. The above example is <strong>symmetrical</strong>.
However, if we have a CPU and we want to model its power dissipation we may have three operating modes with the
following state transitions:</p>
<ul class="simple">
<li>Normal mode</li>
<li>switch to <strong>Power saving mode</strong> if CPU load is below 5%</li>
<li>switch to <strong>Fried mode</strong> if the temperature is above 110 degrees</li>
<li>Power saving mode</li>
<li>switch to <strong>Normal mode</strong> if CPU load is above 5%</li>
<li>switch to <strong>Fried mode</strong> if the temperature is above 110 degrees</li>
<li>Fried mode (no escape from here... go to the nearest shop and buy a new one!)</li>
</ul>
<p>What we can see is that from the <strong>Normal mode</strong> we can either go to the <strong>Power saving mode</strong> or to the <strong>Fried mode</strong>.
The same stands for the <strong>Power saving mode</strong>: we can either go to the <strong>Normal mode</strong> or to the <strong>Fried mode</strong>.
However, once the temperature exceeds 110 degrees the CPU dies (let&#8217;s say we heavily overclocked it) and there
is no going back. This type of discontinuities is called an <strong>irreversible discontinuity</strong> and can be described by
using  <a class="reference internal" href="core.html#pyCore.daeModel.STN" title="pyCore.daeModel.STN"><tt class="xref py py-meth docutils literal"><span class="pre">STN()</span></tt></a>, <a class="reference internal" href="core.html#pyCore.daeModel.STATE" title="pyCore.daeModel.STATE"><tt class="xref py py-meth docutils literal"><span class="pre">STATE()</span></tt></a>, <a class="reference internal" href="core.html#pyCore.daeModel.END_STN" title="pyCore.daeModel.END_STN"><tt class="xref py py-meth docutils literal"><span class="pre">END_STN()</span></tt></a>
functions while state transitions using <a class="reference internal" href="core.html#pyCore.daeModel.ON_CONDITION" title="pyCore.daeModel.ON_CONDITION"><tt class="xref py py-meth docutils literal"><span class="pre">ON_CONDITION()</span></tt></a> function.
In <strong>pyDAE</strong> this type of state transitions is given by the following statement:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">STN</span><span class="p">(</span><span class="s">&quot;CPU&quot;</span><span class="p">)</span>

<span class="n">STATE</span><span class="p">(</span><span class="s">&quot;Normal&quot;</span><span class="p">)</span>
<span class="c">#... (equations go here)</span>
<span class="n">ON_CONDITION</span><span class="p">(</span><span class="n">CPULoad</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">switchToState</span> <span class="o">=</span> <span class="s">&quot;PowerSaving&quot;</span><span class="p">)</span>
<span class="n">ON_CONDITION</span><span class="p">(</span><span class="n">T</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">110</span><span class="p">,</span>        <span class="n">switchToState</span> <span class="o">=</span> <span class="s">&quot;Fried&quot;</span><span class="p">)</span>

<span class="n">STATE</span><span class="p">(</span><span class="s">&quot;PowerSaving&quot;</span><span class="p">)</span>
<span class="c">#... (equations go here)</span>
<span class="n">ON_CONDITION</span><span class="p">(</span><span class="n">CPULoad</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">switchToState</span> <span class="o">=</span> <span class="s">&quot;Normal&quot;</span><span class="p">)</span>
<span class="n">ON_CONDITION</span><span class="p">(</span><span class="n">T</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">110</span><span class="p">,</span>         <span class="n">switchToState</span> <span class="o">=</span> <span class="s">&quot;Fried&quot;</span><span class="p">)</span>

<span class="n">STATE</span><span class="p">(</span><span class="s">&quot;Normal&quot;</span><span class="p">)</span>
<span class="c">#... (equations go here)</span>

<span class="n">END_STN</span><span class="p">()</span>
</pre></div>
</div>
<p>while in <strong>cDAE</strong> by:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">STN</span><span class="p">(</span><span class="s">&quot;CPU&quot;</span><span class="p">);</span>

<span class="n">STATE</span><span class="p">(</span><span class="s">&quot;Normal&quot;</span><span class="p">);</span>
<span class="c1">//... (equations go here)</span>
<span class="n">ON_CONDITION</span><span class="p">(</span><span class="n">CPULoad</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">switchToState</span> <span class="o">=</span> <span class="s">&quot;PowerSaving&quot;</span><span class="p">);</span>
<span class="n">ON_CONDITION</span><span class="p">(</span><span class="n">T</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">110</span><span class="p">,</span>        <span class="n">switchToState</span> <span class="o">=</span> <span class="s">&quot;Fried&quot;</span><span class="p">);</span>


<span class="n">STATE</span><span class="p">(</span><span class="s">&quot;PowerSaving&quot;</span><span class="p">);</span>
<span class="c1">//... (equations go here)</span>
<span class="n">ON_CONDITION</span><span class="p">(</span><span class="n">CPULoad</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">switchToState</span> <span class="o">=</span> <span class="s">&quot;Normal&quot;</span><span class="p">);</span>
<span class="n">ON_CONDITION</span><span class="p">(</span><span class="n">T</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">110</span><span class="p">,</span>         <span class="n">switchToState</span> <span class="o">=</span> <span class="s">&quot;Fried&quot;</span><span class="p">);</span>

<span class="n">STATE</span><span class="p">(</span><span class="s">&quot;Normal&quot;</span><span class="p">);</span>
<span class="c1">//... (equations go here)</span>

<span class="n">END_STN</span><span class="p">();</span>
</pre></div>
</div>
<p>More information about state transition networks can be found in <a class="reference internal" href=""><em>pyDAE User Guide</em></a> and <a class="reference internal" href="core.html#pyCore.daeSTN" title="pyCore.daeSTN"><tt class="xref py py-class docutils literal"><span class="pre">pyCore.daeSTN</span></tt></a>.
Also, do not forget to have a look on <a class="reference internal" href="tutorials.html"><em>Tutorials</em></a>.</p>
</div>
<div class="section" id="ports">
<h3>6.2.6. Ports<a class="headerlink" href="#ports" title="Permalink to this headline">¶</a></h3>
<p>Ports are used to connect two models. Like models, they may contain domains, parameters and variables. For instance,
in <strong>pyDAE</strong> ports can be defined by the following statements:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="k">class</span> <span class="nc">myPort</span><span class="p">(</span><span class="n">daePort</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Name</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Parent</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">Description</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">):</span>
        <span class="n">daePort</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Name</span><span class="p">,</span> <span class="n">Type</span><span class="p">,</span> <span class="n">Parent</span><span class="p">,</span> <span class="n">Description</span><span class="p">)</span>
        <span class="c">#... (here go declarations of domains, parameters and variables)</span>
</pre></div>
</div>
<p>while in <strong>cDAE</strong> by:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">myPort</span> <span class="o">:</span> <span class="k">public</span> <span class="n">daePort</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
<span class="n">myPort</span><span class="p">(</span><span class="n">string</span> <span class="n">strName</span><span class="p">,</span> <span class="n">daeePortType</span> <span class="n">eType</span><span class="p">,</span> <span class="n">daeModel</span><span class="o">*</span> <span class="n">pParent</span><span class="p">,</span> <span class="n">string</span> <span class="n">strDescription</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">daePort</span><span class="p">(</span><span class="n">strName</span><span class="p">,</span> <span class="n">eType</span><span class="p">,</span> <span class="n">pParent</span><span class="p">,</span> <span class="n">strDescription</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">//... (here go additional properties of domains, parameters and variables)</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
    <span class="c1">//... (here go declarations of domains, parameters and variables)</span>
<span class="p">};</span>
</pre></div>
</div>
<p>More information about ports can be found in <a class="reference internal" href=""><em>pyDAE User Guide</em></a> and <a class="reference internal" href="core.html#pyCore.daePort" title="pyCore.daePort"><tt class="xref py py-class docutils literal"><span class="pre">pyCore.daePort</span></tt></a>.
Also, do not forget to have a look on <a class="reference internal" href="tutorials.html"><em>Tutorials</em></a>.</p>
</div>
<div class="section" id="event-ports">
<h3>6.2.7. Event Ports<a class="headerlink" href="#event-ports" title="Permalink to this headline">¶</a></h3>
<p>Event ports are also used to connect two models; however, they allow sending of discrete messages (events) between
model instances. Events can be triggered manually or as a result of a state transition in a model. The main difference
between event and ordinary ports is that the former allow a discrete communication between model instances while
latter allow a continuous exchange of information. A single outlet event port can be connected to unlimited number
of inlet event ports. Messages contain a floating point value that can be used by a recipient (these actions are
specified in <a class="reference internal" href="core.html#pyCore.daeModel.ON_EVENT" title="pyCore.daeModel.ON_EVENT"><tt class="xref py py-meth docutils literal"><span class="pre">ON_EVENT()</span></tt></a> function); that value might be a simple number or an expression
involving model variables/parameters.</p>
<p>More information about event ports can be found in <a class="reference internal" href=""><em>pyDAE User Guide</em></a> and <a class="reference internal" href="core.html#pyCore.daeEventPort" title="pyCore.daeEventPort"><tt class="xref py py-class docutils literal"><span class="pre">pyCore.daeEventPort</span></tt></a>.
Also, do not forget to have a look on <a class="reference internal" href="tutorials.html"><em>Tutorials</em></a>.</p>
</div>
</div>
<div class="section" id="simulation">
<h2>6.3. Simulation<a class="headerlink" href="#simulation" title="Permalink to this headline">¶</a></h2>
<div class="section" id="setting-up-a-simulation">
<h3>6.3.1. Setting up a simulation<a class="headerlink" href="#setting-up-a-simulation" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="setting-up-a-data-reporter">
<h3>6.3.2. Setting up a data reporter<a class="headerlink" href="#setting-up-a-data-reporter" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="setting-up-a-dae-solver">
<h3>6.3.3. Setting up a DAE solver<a class="headerlink" href="#setting-up-a-dae-solver" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="setting-up-a-log">
<h3>6.3.4. Setting up a log<a class="headerlink" href="#setting-up-a-log" title="Permalink to this headline">¶</a></h3>
</div>
</div>
<div class="section" id="optimization">
<h2>6.4. Optimization<a class="headerlink" href="#optimization" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="parameter-estimation">
<h2>6.5. Parameter estimation<a class="headerlink" href="#parameter-estimation" title="Permalink to this headline">¶</a></h2>
<img alt="" src="http://sourceforge.net/apps/piwik/daetools/piwik.php?idsite=1&amp;amp;rec=1&amp;amp;url=wiki/" />
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/[d][a][e]_Tools_project.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">6. pyDAE User Guide</a><ul>
<li><a class="reference internal" href="#importing-dae-tools-modules">6.1. Importing DAE Tools modules</a></li>
<li><a class="reference internal" href="#developing-models">6.2. Developing models</a><ul>
<li><a class="reference internal" href="#parameters">6.2.1. Parameters</a><ul>
<li><a class="reference internal" href="#declaring-parameters">6.2.1.1. Declaring parameters</a></li>
<li><a class="reference internal" href="#initializing-parameters">6.2.1.2. Initializing parameters</a></li>
<li><a class="reference internal" href="#using-parameters">6.2.1.3. Using parameters</a></li>
</ul>
</li>
<li><a class="reference internal" href="#variables">6.2.2. Variables</a></li>
<li><a class="reference internal" href="#distribution-domains">6.2.3. Distribution domains</a></li>
<li><a class="reference internal" href="#equations">6.2.4. Equations</a><ul>
<li><a class="reference internal" href="#defining-equations-equation-residual-expression">6.2.4.1. Defining equations (equation residual expression)</a></li>
<li><a class="reference internal" href="#defining-boundary-conditions">6.2.4.2. Defining boundary conditions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#state-transition-networks">6.2.5. State Transition Networks</a></li>
<li><a class="reference internal" href="#ports">6.2.6. Ports</a></li>
<li><a class="reference internal" href="#event-ports">6.2.7. Event Ports</a></li>
</ul>
</li>
<li><a class="reference internal" href="#simulation">6.3. Simulation</a><ul>
<li><a class="reference internal" href="#setting-up-a-simulation">6.3.1. Setting up a simulation</a></li>
<li><a class="reference internal" href="#setting-up-a-data-reporter">6.3.2. Setting up a data reporter</a></li>
<li><a class="reference internal" href="#setting-up-a-dae-solver">6.3.3. Setting up a DAE solver</a></li>
<li><a class="reference internal" href="#setting-up-a-log">6.3.4. Setting up a log</a></li>
</ul>
</li>
<li><a class="reference internal" href="#optimization">6.4. Optimization</a></li>
<li><a class="reference internal" href="#parameter-estimation">6.5. Parameter estimation</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="getting_started.html"
                        title="previous chapter">5. Getting Started with DAE Tools</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="pyDAE_api_ref.html"
                        title="next chapter">7. pyDAE API Reference</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/pyDAE_user_guide.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="pyDAE_api_ref.html" title="7. pyDAE API Reference"
             >next</a> |</li>
        <li class="right" >
          <a href="getting_started.html" title="5. Getting Started with DAE Tools"
             >previous</a> |</li>
        <li><a href="index.html">DAE Tools Project 1.3.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2008-2013, Dragan Nikolic.
      Last updated on May 24, 2013.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>