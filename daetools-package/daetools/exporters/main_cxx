/***********************************************************************************
*                 DAE Tools Project: www.daetools.com
*                 Copyright (C) Dragan Nikolic, 2010
************************************************************************************
DAE Tools is free software; you can redistribute it and/or modify it under the
terms of the GNU General Public License version 3 as published by the Free Software
Foundation. DAE Tools is distributed in the hope that it will be useful, but WITHOUT
ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.
You should have received a copy of the GNU General Public License along with the
DAE Tools software; if not, see <http://www.gnu.org/licenses/>.
***********************************************************************************/
#include "daetools_model.h"

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

#include <idas/idas.h>
#include <idas/idas_dense.h>
#include <sundials/sundials_math.h>
#include <nvector/nvector_serial.h>

#define JACOBIAN(A) (A->cols)

int resrob(realtype tres, N_Vector yy, N_Vector yp,
           N_Vector resval, void *user_data);

static int grob(realtype t, N_Vector yy, N_Vector yp,
                realtype *gout, void *user_data);

int jacrob(long int Neq, realtype tt,  realtype cj,
           N_Vector yy, N_Vector yp, N_Vector resvec,
           DlsMat JJ, void *user_data,
           N_Vector tempv1, N_Vector tempv2, N_Vector tempv3);

/* Prototypes of private functions */
static void PrintHeader(realtype rtol, N_Vector avtol, N_Vector y);
static void PrintOutput(void *mem, realtype t, N_Vector y);
static void PrintRootInfo(int root_f1, int root_f2);
static void PrintFinalStats(void *mem);
static int check_flag(void *flagvalue, char *funcname, int opt);

int main(int argc, char *argv[])
{
    int i;
    void *mem;
    N_Vector yy, yp, avtol, ids;
    realtype rtol, *yval, *ypval, *atval, *idsval;
    realtype t0, tout, tret;
    int iout, retval, retvalr;
    int rootsfound[2];

    mem = NULL;
    yy = yp = avtol = NULL;
    yval = ypval = atval = NULL;

    initial_values();

    /* Allocate N-vectors. */
    yy = N_VNew_Serial(_Neqns_);
    if(check_flag((void *)yy, "N_VNew_Serial", 0))
        return(1);

    yp = N_VNew_Serial(_Neqns_);
    if(check_flag((void *)yp, "N_VNew_Serial", 0))
        return(1);

    avtol = N_VNew_Serial(_Neqns_);
    if(check_flag((void *)avtol, "N_VNew_Serial", 0))
        return(1);

    ids = N_VNew_Serial(_Neqns_);
    if(check_flag((void *)avtol, "N_VNew_Serial", 0))
        return(1);

    /* Create and initialize  y, y', and absolute tolerance vectors. */
    yval  = NV_DATA_S(yy);
    for(i = 0; i < _Neqns_; i++)
        yval[i] = _initValues_[ _indexMap_[i] ];

    ypval = NV_DATA_S(yp);
    for(i = 0; i < _Neqns_; i++)
        ypval[i] = 0;

    rtol = RCONST(1.0e-5);

    atval = NV_DATA_S(avtol);
    for(i = 0; i < _Neqns_; i++)
        atval[i] = 1E-6;

    idsval  = NV_DATA_S(ids);
    for(i = 0; i < _Neqns_; i++)
        idsval[i] = (realtype)_IDs_[ _indexMap_[i] ];

    /* Integration limits */
    t0 = 0;
    tout = 200;

    PrintHeader(rtol, avtol, yy);

    /* Call IDACreate and IDAMalloc to initialize IDA memory */
    mem = IDACreate();
    if(check_flag((void *)mem, "IDACreate", 0))
        return(1);

    retval = IDASetId(mem, ids);
    if(check_flag(&retval, "IDASetId", 1))
        return(1);

    retval = IDAInit(mem, resrob, t0, yy, yp);
    if(check_flag(&retval, "IDAInit", 1))
        return(1);

    retval = IDASVtolerances(mem, rtol, avtol);
    if(check_flag(&retval, "IDASVtolerances", 1)) return(1);

    /* Free avtol */
    N_VDestroy_Serial(avtol);
    N_VDestroy_Serial(ids);

    /* Call IDARootInit to specify the root function grob with 2 components */
    //    int no_roots = number_of_roots(t0, yy, yp);
    //    retval = IDARootInit(mem, no_roots, roots);
    //    if (check_flag(&retval, "IDARootInit", 1))
    //        return(1);

    /* Call IDADense and set up the linear solver. */
    retval = IDADense(mem, _Neqns_);
    if(check_flag(&retval, "IDADense", 1))
        return(1);

    retval = IDADlsSetDenseJacFn(mem, jacrob);
    if(check_flag(&retval, "IDADlsSetDenseJacFn", 1))
        return(1);

    /* In loop, call IDASolve, print results, and test for error.
       Break out of loop when NOUT preset output times have been reached. */

    retval = IDACalcIC(mem, IDA_YA_YDP_INIT, 0.1);
    if(check_flag(&retval, "IDACalcIC", 1))
        return(1);

    realtype t;
    for(t = t0+10; t <= tout; t += 10)
    {

        retval = IDASolve(mem, t, &tret, yy, yp, IDA_NORMAL);

        PrintOutput(mem,tret,yy);

        if(check_flag(&retval, "IDASolve", 1))
            return(1);
    }

    PrintFinalStats(mem);

    /* Free memory */

    IDAFree(&mem);
    N_VDestroy_Serial(yy);
    N_VDestroy_Serial(yp);

    return 0;
}

int resrob(realtype tres, N_Vector yy, N_Vector yp,
           N_Vector resval, void *user_data)
{
    realtype* yval   = NV_DATA_S(yy);
    realtype* ypval  = NV_DATA_S(yp);
    realtype* res    = NV_DATA_S(resval);

    return residuals(tres, yval, ypval, res);
}

int grob(realtype t, N_Vector yy, N_Vector yp,
         realtype *gout, void *user_data)
{
    realtype* yval   = NV_DATA_S(yy);
    realtype* ypval  = NV_DATA_S(yp);

    return roots(t, yval, ypval, gout);
}

int jacrob(long int Neq, realtype tt,  realtype cj,
           N_Vector yy, N_Vector yp, N_Vector resvec,
           DlsMat JJ, void *user_data,
           N_Vector tempv1, N_Vector tempv2, N_Vector tempv3)
{
    realtype* yval   = NV_DATA_S(yy);
    realtype* ypval  = NV_DATA_S(yp);
    realtype* res    = NV_DATA_S(resvec);
    realtype** jacob = JACOBIAN(JJ);

    return jacobian(Neq, tt,  cj, yval, ypval, res, jacob);
}

/*
 * Print first lines of output (problem description)
 */

static void PrintHeader(realtype rtol, N_Vector avtol, N_Vector y)
{
    realtype *atval, *yval;

    atval  = NV_DATA_S(avtol);
    yval  = NV_DATA_S(y);

    printf("\nidasRoberts_dns: Robertson kinetics DAE serial example problem for IDA.\n");
    printf("               Three equation chemical kinetics problem.\n\n");
    printf("Linear solver: IDADENSE, with user-supplied Jacobian.\n");
#if defined(SUNDIALS_EXTENDED_PRECISION)
    printf("Tolerance parameters:  rtol = %Lg   atol = %Lg %Lg %Lg \n",
           rtol, atval[0],atval[1],atval[2]);
    printf("Initial conditions y0 = (%Lg %Lg %Lg)\n",
           yval[0], yval[1], yval[2]);
#elif defined(SUNDIALS_DOUBLE_PRECISION)
    printf("Tolerance parameters:  rtol = %lg   atol = %lg %lg %lg \n",
           rtol, atval[0],atval[1],atval[2]);
    printf("Initial conditions y0 = (%lg %lg %lg)\n",
           yval[0], yval[1], yval[2]);
#else
    printf("Tolerance parameters:  rtol = %g   atol = %g %g %g \n",
           rtol, atval[0],atval[1],atval[2]);
    printf("Initial conditions y0 = (%g %g %g)\n",
           yval[0], yval[1], yval[2]);
#endif
    printf("Constraints and id not used.\n\n");
    printf("-----------------------------------------------------------------------\n");
    printf("  t             y1           y2           y3");
    printf("      | nst  k      h\n");
    printf("-----------------------------------------------------------------------\n");
}

/*
 * Print Output
 */

static void PrintOutput(void *mem, realtype t, N_Vector y)
{
    realtype *yval;
    int retval, kused;
    long int nst;
    realtype hused;

    yval  = NV_DATA_S(y);

    retval = IDAGetLastOrder(mem, &kused);
    check_flag(&retval, "IDAGetLastOrder", 1);
    retval = IDAGetNumSteps(mem, &nst);
    check_flag(&retval, "IDAGetNumSteps", 1);
    retval = IDAGetLastStep(mem, &hused);
    check_flag(&retval, "IDAGetLastStep", 1);
#if defined(SUNDIALS_EXTENDED_PRECISION)
    printf("%10.4Le %12.4Le %12.4Le %12.4Le | %3ld  %1d %12.4Le\n",
           t, yval[0], yval[1], yval[2], nst, kused, hused);
#elif defined(SUNDIALS_DOUBLE_PRECISION)
    printf("%10.4le %12.4le %12.4le %12.4le | %3ld  %1d %12.4le\n",
           t, yval[0], yval[1], yval[2], nst, kused, hused);
#else
    printf("%10.4e %12.4e %12.4e %12.4e | %3ld  %1d %12.4e\n",
           t, yval[0], yval[1], yval[2], nst, kused, hused);
#endif
}

static void PrintRootInfo(int root_f1, int root_f2)
{
    printf("    rootsfound[] = %3d %3d\n", root_f1, root_f2);
    return;
}

/*
 * Print final integrator statistics
 */

static void PrintFinalStats(void *mem)
{
    int retval;
    long int nst, nni, nje, nre, nreLS, netf, ncfn, nge;

    retval = IDAGetNumSteps(mem, &nst);
    check_flag(&retval, "IDAGetNumSteps", 1);
    retval = IDAGetNumResEvals(mem, &nre);
    check_flag(&retval, "IDAGetNumResEvals", 1);
    retval = IDADlsGetNumJacEvals(mem, &nje);
    check_flag(&retval, "IDADlsGetNumJacEvals", 1);
    retval = IDAGetNumNonlinSolvIters(mem, &nni);
    check_flag(&retval, "IDAGetNumNonlinSolvIters", 1);
    retval = IDAGetNumErrTestFails(mem, &netf);
    check_flag(&retval, "IDAGetNumErrTestFails", 1);
    retval = IDAGetNumNonlinSolvConvFails(mem, &ncfn);
    check_flag(&retval, "IDAGetNumNonlinSolvConvFails", 1);
    retval = IDADlsGetNumResEvals(mem, &nreLS);
    check_flag(&retval, "IDADlsGetNumResEvals", 1);
    retval = IDAGetNumGEvals(mem, &nge);
    check_flag(&retval, "IDAGetNumGEvals", 1);

    printf("\nFinal Run Statistics: \n\n");
    printf("Number of steps                    = %ld\n", nst);
    printf("Number of residual evaluations     = %ld\n", nre+nreLS);
    printf("Number of Jacobian evaluations     = %ld\n", nje);
    printf("Number of nonlinear iterations     = %ld\n", nni);
    printf("Number of error test failures      = %ld\n", netf);
    printf("Number of nonlinear conv. failures = %ld\n", ncfn);
    printf("Number of root fn. evaluations     = %ld\n", nge);
}

/*
 * Check function return value...
 *   opt == 0 means SUNDIALS function allocates memory so check if
 *            returned NULL pointer
 *   opt == 1 means SUNDIALS function returns a flag so check if
 *            flag >= 0
 *   opt == 2 means function allocates memory so check if returned
 *            NULL pointer
 */

static int check_flag(void *flagvalue, char *funcname, int opt)
{
    int *errflag;
    /* Check if SUNDIALS function returned NULL pointer - no memory allocated */
    if (opt == 0 && flagvalue == NULL) {
        fprintf(stderr,
                "\nSUNDIALS_ERROR: %s() failed - returned NULL pointer\n\n",
                funcname);
        return(1);
    } else if (opt == 1) {
        /* Check if flag < 0 */
        errflag = (int *) flagvalue;
        if (*errflag < 0) {
            fprintf(stderr,
                    "\nSUNDIALS_ERROR: %s() failed with flag = %d\n\n",
                    funcname, *errflag);
            return(1);
        }
    } else if (opt == 2 && flagvalue == NULL) {
        /* Check if function returned NULL pointer - no memory allocated */
        fprintf(stderr,
                "\nMEMORY_ERROR: %s() failed - returned NULL pointer\n\n",
                funcname);
        return(1);
    }

    return(0);
}
